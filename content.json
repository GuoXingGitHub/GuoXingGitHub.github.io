{"meta":{"title":"阿兴的博客","subtitle":null,"description":null,"author":"AX Blog","url":"http://axss.gitee.io"},"pages":[{"title":"","date":"2018-03-13T02:58:44.847Z","updated":"2018-03-13T02:58:44.847Z","comments":true,"path":"标准.html","permalink":"http://axss.gitee.io/标准.html","excerpt":"","text":"标题标准标题默认从##开始，"},{"title":"404 Not Found：该页无法显示","date":"2018-03-13T02:58:44.786Z","updated":"2018-03-13T02:58:44.786Z","comments":false,"path":"/404.html","permalink":"http://axss.gitee.io//404.html","excerpt":"","text":""},{"title":"关于/留言","date":"2018-03-13T05:07:28.333Z","updated":"2018-03-13T05:07:28.333Z","comments":true,"path":"about/index.html","permalink":"http://axss.gitee.io/about/index.html","excerpt":"","text":"12345678910111213141516&#123; name: '阿兴', address: '广东省广州市', QQ: 1069784176 github: 'https://github.com/GuoXingGitHub', blog: 'http://axss.gitee.io', email: '15692413487@163.com', description: 'hahaha...', skills: [ ['C', 'C++', 'C#', '.Net', 'Sql', 'Js'], ['Linux', 'Qt'], ['网站开发', '游戏服务器'], ['数据库'], ]&#125;"},{"title":"分类","date":"2018-03-13T03:34:32.996Z","updated":"2018-03-13T03:34:32.996Z","comments":false,"path":"categories/index.html","permalink":"http://axss.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"音乐","date":"2018-03-13T08:54:42.226Z","updated":"2018-03-13T08:54:42.225Z","comments":false,"path":"musics/index.html","permalink":"http://axss.gitee.io/musics/index.html","excerpt":"","text":"iframe{ height:350px }"},{"title":"友情链接","date":"2018-03-13T02:58:44.846Z","updated":"2018-03-13T02:58:44.846Z","comments":true,"path":"links/index.html","permalink":"http://axss.gitee.io/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2018-03-13T02:58:44.846Z","updated":"2018-03-13T02:58:44.846Z","comments":false,"path":"books/index.html","permalink":"http://axss.gitee.io/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-03-13T02:58:44.847Z","updated":"2018-03-13T02:58:44.847Z","comments":false,"path":"repository/index.html","permalink":"http://axss.gitee.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-03-13T03:34:38.997Z","updated":"2018-03-13T03:34:38.996Z","comments":false,"path":"tags/index.html","permalink":"http://axss.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"VS插件VASSISTX(小番茄)创建注释模板","slug":"技术/2018-03-14-VS插件VASSISTX(小番茄)创建注释模板","date":"2018-03-14T07:00:42.000Z","updated":"2018-03-14T13:12:03.823Z","comments":true,"path":"2018/03/14/技术/2018-03-14-VS插件VASSISTX(小番茄)创建注释模板/","link":"","permalink":"http://axss.gitee.io/2018/03/14/技术/2018-03-14-VS插件VASSISTX(小番茄)创建注释模板/","excerpt":"","text":"前言VASSISTX是vs的一款插件,可以大大提高程序的开发效率,VASSISTX的安装和破解可以自己百度,这里主要讲的是使用它的快速生成模板的功能 步骤安装好VASSISTX后选择操作栏上的VASSISTX然后打开Visual Assist Options 选择Suggestions 再选择Edit VA Snippets 就能看到下图界面我们需要new一个然后可以选择一个下方现有的模板复制到我们新增的模板里,可以按照自己的要求修改最后输入Title和Shortcut，这个Shortcut是我们在启动命令(在vs界面输入的时候VASSISTX自动会检测,检测到我们只需选择后按tab或者enter建即可显示我们需要追加的模板) 常用注释格式12345678910111213141516171819202122232425262728293031323334353637//1、生成文件头注释 /************************************************************************** * @Copyright (c) $YEAR$, AX, All rights reserved. * @file : $FILE_BASE$.$FILE_EXT$ * @version : ver 1.0 * @author : AX * @date : $YEAR$/$MONTH_02$/$DAY_02$ $HOUR_02$:$MINUTE$ * @brief : $brief$ **************************************************************************/ //2、生成函数功能注释 /******************************************************** * @function : * @brief : $brief$ * @input : * @output : * @return : 成功返回0，失败返回非0 * @author : AX $YEAR$/$MONTH_02$/$DAY_02$ $HOUR_02$:$MINUTE$ ********************************************************/ //3、生成类//2、生成函数功能注释 /******************************************************** * @class : * @brief : $brief$ * @author : AX $YEAR$/$MONTH_02$/$DAY_02$ $HOUR_02$:$MINUTE$ ********************************************************/ //4、生成单行标记 //-------By_AX_$YEAR$/$MONTH_02$/$DAY_02$ $HOUR_02$:$MINUTE$ //5、生成多行标记 /*-----------------By_AX_$YEAR$/$MONTH_02$/$DAY_02$ $HOUR_02$:$MINUTE$-----------------*/ /*------------------------------------------------------------*/","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"},{"name":"工具/插件","slug":"工具-插件","permalink":"http://axss.gitee.io/tags/工具-插件/"},{"name":"c++","slug":"c","permalink":"http://axss.gitee.io/tags/c/"},{"name":"csharp","slug":"csharp","permalink":"http://axss.gitee.io/tags/csharp/"},{"name":"python","slug":"python","permalink":"http://axss.gitee.io/tags/python/"},{"name":".net","slug":"net","permalink":"http://axss.gitee.io/tags/net/"}]},{"title":"python编写规范pep8的问题笔记","slug":"技术/2018-03-09-python编写规范pep8的问题笔记","date":"2018-03-12T12:46:25.000Z","updated":"2018-03-13T02:58:44.820Z","comments":true,"path":"2018/03/12/技术/2018-03-09-python编写规范pep8的问题笔记/","link":"","permalink":"http://axss.gitee.io/2018/03/12/技术/2018-03-09-python编写规范pep8的问题笔记/","excerpt":"","text":"字数,函数限制一行列数: PEP 8 规定为 79 列，这个太苛刻了，如果要拼接url一般都会超。一个函数: 不要超过 30 行代码, 即可显示在一个屏幕类，可以不使用垂直游标即可看到整个函数。一个类: 不要超过 200 行代码，不要有超过 10 个方法。一个模块: 不要超过 500 行。 不要在一句import中多个库不推荐:import os, sys推荐:import osimport sys 错误记录错误记录: W292 no newline at end of file处理:打个回车有新的一空行即可（新行不要有空格 错误记录:E302 expected 2 blank lines, found 1处理:上面只有一行空白，但是需要两个空白行 错误记录:E231 missing whitespace after ‘,’翻译:“，”后要有空格举例:错误 print(“%s %s %s %s %s %s” % (A,B,D,E,K,L))正确 print(“%s %s %s %s %s %s” % (A, B, D, E, K, L)) 错误记录:E225 missing whitespace around operator翻译:举例:错误 print(“%s %s %s %s %s %s”%(A, B, D, E, K, L))正确 rint(“%s %s %s %s %s %s”% (A, B, D, E, K, L)) 错误记录:E225 missing whitespace around operator举例:错误 f=open(“D:\\test.txt”, “ab”)正确 f = open(“D:\\test.txt”, “ab”) 本文引用自：http://www.simonzhang.net/?p=1072","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"python","slug":"python","permalink":"http://axss.gitee.io/tags/python/"}]},{"title":"图片","slug":"生活/2018-03-10-图片","date":"2018-03-12T08:40:41.000Z","updated":"2018-03-13T02:58:44.844Z","comments":true,"path":"2018/03/12/生活/2018-03-10-图片/","link":"","permalink":"http://axss.gitee.io/2018/03/12/生活/2018-03-10-图片/","excerpt":"","text":"","categories":[{"name":"生活","slug":"生活","permalink":"http://axss.gitee.io/categories/生活/"}],"tags":[{"name":"生活随笔","slug":"生活随笔","permalink":"http://axss.gitee.io/tags/生活随笔/"}]},{"title":"C#学习笔记.exe下载","slug":"技术/2018-03-10-csharp学习笔记","date":"2018-03-12T07:09:23.000Z","updated":"2018-03-13T02:58:44.828Z","comments":true,"path":"2018/03/12/技术/2018-03-10-csharp学习笔记/","link":"","permalink":"http://axss.gitee.io/2018/03/12/技术/2018-03-10-csharp学习笔记/","excerpt":"","text":"点击下载 C#学习笔记.exe","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"工具/插件","slug":"工具-插件","permalink":"http://axss.gitee.io/tags/工具-插件/"},{"name":"csharp","slug":"csharp","permalink":"http://axss.gitee.io/tags/csharp/"}]},{"title":"C#代码的编译过程","slug":"技术/2018-03-10-csharp代码的编译过程","date":"2018-03-12T07:04:49.000Z","updated":"2018-03-13T02:58:44.827Z","comments":true,"path":"2018/03/12/技术/2018-03-10-csharp代码的编译过程/","link":"","permalink":"http://axss.gitee.io/2018/03/12/技术/2018-03-10-csharp代码的编译过程/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"csharp","slug":"csharp","permalink":"http://axss.gitee.io/tags/csharp/"}]},{"title":"vscode配置c,c++环境","slug":"技术/2018-03-14-vscode配置c,c++环境","date":"2018-03-12T07:00:42.000Z","updated":"2018-03-14T13:03:56.972Z","comments":true,"path":"2018/03/12/技术/2018-03-14-vscode配置c,c++环境/","link":"","permalink":"http://axss.gitee.io/2018/03/12/技术/2018-03-14-vscode配置c,c++环境/","excerpt":"","text":"前言 官网教程: C/C++ for VS Code (Preview) 参考教程: Visual Studio Code如何编写运行C、C++ 安装ide和编译器,调试器的安装vscode官网Clang下载,选Pre-Built Binaries中的Clang for Windows (64-bit),不需要下.sig文件MinGW-w64下载,直接Download Clang 下载好了以后安装。添加环境变量时：选Add LLVM to the system PATH for all users（即第二项，不过第三项也差不多）。Clang的安装路径（Destination folder）我推荐填C:\\LLVM，不装那里也行，下面的配置里路径就自己改。安装完了以后可能会弹出cmd说MSVC integration install failed。这个是因为Clang默认使用的是msvc的工具链，而我们选择的工具链是MinGW，所以就不用管这个提示。如果你想用别的工具链，参考第九点。 MinGW随便装哪，Architecture选x86_64，装好以后把东西全部复制到Clang的文件夹里去，他们会无冲突合并，效果图见下。同样，不做这一步也行，下面的配置里路径就自己改，还要手动把MinGW的bin文件夹加到path中，因为MinGW不会自己加。至于为什么既要装Clang又要装MinGW，是因为Clang没有头文件。然后就可以把MinGW删了（Uninstall.exe）。不建议安装多个MinGW；可以把其他轻量IDE的编译器设为Clang，并把其他的MinGW从环境变量中去掉。 插件安装C/C++（就是有些教程里的cpptools）C/C++ Clang Command Adapter：提供静态检测（Lint）Code RunnerInclude Autocomplete：提供头文件补全C/C++ Snippets：Snippets即重用代码块 可选插件Bracket Pair Colorizer：彩虹花括号One Dark Pro：大概是VS Code安装量最高的主题GBKtoUTF8：把GBK编码的文档转换成UTF8编码的 配置.vscode 的 四个json文件c_cpp_properties.json123456789101112131415161718192021222324252627282930313233343536373839&#123; \"configurations\": [ &#123; \"name\": \"Win32\", \"intelliSenseMode\": \"clang-x64\", \"includePath\": [ \"$&#123;workspaceFolder&#125;\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include/c++\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include/c++/x86_64-w64-mingw32\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include/c++/backward\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include\", \"D:/Program Files/llvm/include\", \"D:/Program Files/llvm/x86_64-w64-mingw32/include\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include-fixed\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"__GNUC__=7\", \"__cdecl=__attribute__((__cdecl__))\" ], \"browse\": &#123; \"path\": [ \"$&#123;workspaceFolder&#125;\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include/c++\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include/c++/x86_64-w64-mingw32\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include/c++/backward\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include\", \"D:/Program Files/llvm/include\", \"D:/Program Files/llvm/x86_64-w64-mingw32/include\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include-fixed\" ], \"limitSymbolsToIncludedHeaders\": true, \"databaseFilename\": \"\" &#125; &#125; ], \"version\": 3&#125; 具体路径改成自己的clang的安装路径 launch.json12345678910111213141516171819202122232425262728// https://github.com/Microsoft/vscode-cpptools/blob/master/launch.md&#123; \"version\": \"0.2.0\", \"configurations\": [ &#123; \"name\": \"(gdb) Launch\", // 配置名称，将会在启动配置的下拉菜单中显示 \"type\": \"cppdbg\", // 配置类型，这里只能为cppdbg \"request\": \"launch\", // 请求配置类型，可以为launch（启动）或attach（附加） \"program\": \"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe\", // 将要进行调试的程序的路径 \"args\": [], // 程序调试时传递给程序的命令行参数，一般设为空即可 \"stopAtEntry\": true, // 设为true时程序将暂停在程序入口处，我一般设置为true \"cwd\": \"$&#123;workspaceFolder&#125;\", // 调试程序时的工作目录 \"environment\": [], // （环境变量？） \"externalConsole\": true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 \"internalConsoleOptions\": \"neverOpen\", // 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡，你应该不需要对gdb手动输命令吧？ \"MIMode\": \"gdb\", // 指定连接的调试器，可以为gdb或lldb。但目前lldb在windows下没有预编译好的版本。 \"miDebuggerPath\": \"gdb.exe\", // 调试器路径。 \"setupCommands\": [ &#123; \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": false &#125; ], \"preLaunchTask\": \"Compile\" // 调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应 &#125; ]&#125; tasks.json12345678910111213141516171819202122232425262728// https://github.com/Microsoft/vscode-cpptools/blob/master/launch.md&#123; \"version\": \"0.2.0\", \"configurations\": [ &#123; \"name\": \"(gdb) Launch\", // 配置名称，将会在启动配置的下拉菜单中显示 \"type\": \"cppdbg\", // 配置类型，这里只能为cppdbg \"request\": \"launch\", // 请求配置类型，可以为launch（启动）或attach（附加） \"program\": \"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe\", // 将要进行调试的程序的路径 \"args\": [], // 程序调试时传递给程序的命令行参数，一般设为空即可 \"stopAtEntry\": true, // 设为true时程序将暂停在程序入口处，我一般设置为true \"cwd\": \"$&#123;workspaceFolder&#125;\", // 调试程序时的工作目录 \"environment\": [], // （环境变量？） \"externalConsole\": true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 \"internalConsoleOptions\": \"neverOpen\", // 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡，你应该不需要对gdb手动输命令吧？ \"MIMode\": \"gdb\", // 指定连接的调试器，可以为gdb或lldb。但目前lldb在windows下没有预编译好的版本。 \"miDebuggerPath\": \"gdb.exe\", // 调试器路径。 \"setupCommands\": [ &#123; \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": false &#125; ], \"preLaunchTask\": \"Compile\" // 调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应 &#125; ]&#125; 其他设置 seting12345678910\"editor.fontFamily\": \"Consolas, 微软雅黑\", // 控制编辑器字体\"workbench.colorTheme\": \"One Dark Pro\", // 主题\"files.trimTrailingWhitespace\": true, // 保存时，删除每一行末尾的空格\"workbench.colorCustomizations\": &#123; \"activityBar.foreground\": \"#33ff66\" // 自定义颜色 &#125;,\"git.enabled\": false, // 如果你不用git，我建议你关闭它\"editor.minimap.enabled\": false, // 我个人不用minimap，就是右边那个东西\"editor.dragAndDrop\": false, // 选中文字后，可以拖动它们调整位置。我是不需要\"files.autoGuessEncoding\": true // 启用后，会在打开文件时尝试猜测字符集编码 详情请参考 https://www.zhihu.com/question/30315894","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"},{"name":"工具/插件","slug":"工具-插件","permalink":"http://axss.gitee.io/tags/工具-插件/"},{"name":"c++","slug":"c","permalink":"http://axss.gitee.io/tags/c/"}]},{"title":"最全的前端资源教程","slug":"技术/2018-03-10-最全的前端资源教程","date":"2018-03-12T07:00:42.000Z","updated":"2018-03-14T13:03:52.187Z","comments":true,"path":"2018/03/12/技术/2018-03-10-最全的前端资源教程/","link":"","permalink":"http://axss.gitee.io/2018/03/12/技术/2018-03-10-最全的前端资源教程/","excerpt":"","text":"Javascript Article Article Javascript深浅拷贝 Javascript中的apply和call继承 Javascript的jsonp原理 Javascript监听触摸事件 Javascript中的var self = this Javascript面向对象编程 Javascript滑屏切换场景 Javascript获取经纬度，关于调用百度API的问题 妙用Javascript运算符 深入理解Javascript函数编程 Javascript的setTimeout详细用例 sessionstorage，localstorage和cookie JS日期对比 JSONP参考文章 Javascript的createElement Javascript的createDocumentFragment sessionStorage和localStorage 像素帧动画 Reference Reference 收集最全前端学习资料 最全前端教程-猫的回忆录 JavaScript中的this陷阱的最全收集–没有之一 JS函数式编程指南 JavaScript Promise迷你书（中文版） 阮一峰 Javascript 前端 TOP 100 小白的零基础JavaScript全栈教程 UI Reference Reference WeUI Bootstrap MUI-最接近原生APP体验的高性能前端框架 Amaze UI中国首个开源HTML5跨屏前端框架 Frozen UI Foundation SUI ZUI 淘宝HTML5前端框架 KISSY - 阿里前端JavaScript库 网易Nej - Nice Easy Javascript Kendo UI MVVM Demo Smart UI 雅虎UI - CSS UI CSS Article Article CSS Flex布局 移动前端开发CSS3 响应式布局 媒体查询 CSS图片响应式布局 lessDemo的less文件 Reference Reference CSS 语法参考 CSS3动画手册 腾讯css3动画制作工具 animate.css Animated Books with CSS 3D Transforms Browserhacks HTML Article Article HTML5有哪些让你惊艳的demo|Wallpaperbetter| Angular Article Angular文档 Angular源码解读publishExternalAPI函数 Angular源码解读setupModuleLoader函数 Angular的ng-style用法 Angular判断在那个浏览器下打开的服务 Angular文字折叠展开组件的原理分析 Angular服务Request异步请求的详细分析 Angular自定义service服务详解 Angular自定义判断上一页是否存在的服务 Angular操作cookies方法 Angular打印错误的minErr函数 Angular的fromJson与toJson方法 Angular用ng-repeat生成表单并绑定ng-click时的一个细节 Angular的run方法巧妙运用 Angular处理Html转义问题 ng-repeat绑定事件和嵌套 Angular的post请求后台接受不了数据的解决方法 ionic总结 ui-route和ng-route ng-options&amp;&amp;ng-switch directive组件作用域 表单认证 $broadcast,$emit and $on 自定义过滤器 自定义手势指令ng-touch ng-animate 单页面应用的技术点 Guess you like AppDemo Angular商城Demo Angular的Cnode社区 AngularStovepipe Angular的新闻客户端 Angular商城Demo Angular的Cnode社区 Angular内联编辑器 Angular即时搜索 Angular导航菜单 Angular订单表单 Angular切换网格 Angular新闻＋WEUI DEMO 源码 Controller 控制器 Angular控制器demo SPA DEMO 单页面应用 Angular+Weui单页面应用DEMO-每日笑话 Service 服务 Angular自定义服务的常用方法 Angular部分服务demo Angular自定义Canvas画图服务 Angular自定义http服务 面向对象封装 Directive 组件与指令 Angular自定义手势指令 Angular自定义轮播图组件 Angular自定义下拉刷新组件1 Angular自定义下拉刷新组件2 Router 路由 Angular路由嵌套 Angular路由单页多个ui-view Filter 过滤器 Angular自带过滤器 Angular自定义关键词检索过滤器 Animate 动画 Angular ng-animate动画1 Angular ng-animate动画2 Other 其他 Angular中使用iframe Angular三级联动(1) Angular中使用ng-switch 百度定位DEMO Angular三级联动(2) Angular事件监听 jQuery模拟ng-repeat lessDemo Angular自定义cookie服务和ngCookie的使用 图灵机器人 Angular利用angular.module()实现模块化 Angular的form表单验证 Angular的ng-repeat嵌套 Angular利用angular.module()实现模块化2 PHP PHP PHP CURL请求的小细节 Reference Reference 最流行的PHP 代码规范 最流行的PHP 代码规范 Angular.js的一些学习资源 Angularjs中文社区 一些扩展Angular UI组件 Angular UI AngularJS在线教程 Angular学习笔记 React React Reference React教程 菜鸟教程 React Router 使用教程 React开发中文手册-极客学院 React教程-汇智网 React.js快速开始 Reactjs 2016最佳实践 React 入门教程 汇智网 React教程 轻松入门React和Webpack React中文索引 Redux 中文文档 React Router官方文档中文翻译 React入门教程 React介绍及实践教程 React.js 官方网址 React.js 官方文档 React.js material UI React.js TouchstoneJS UI React.js amazeui UI React 入门实例教程 - 阮一峰 React Native 中文版 Webpack 和 React 小书 - gitbook Vue Vue AppDemo Demo NewsDemo vue计算属性 vue生命周期 Article Vue文档 Vue-cli脚手架 Vue组件 vue自定义指令 Vue过渡动画 Vue指令 Vue api文档 Vue执行ajax请求 vue实现类似angular服务的方法 Vue源码参考文档 Router 路由 路由demo 路由demo2 Directive 指令 指令demo 自定义指令demo 滑动手势demo Filter 过滤器 过滤器demo 过滤器实现分页demo 过滤器读写数据 Transition 过渡 过渡demo 过渡demo2 Form 表单 获取表单值 Computed 计算 计算属性 Component 组件 组件demo Reference Reference Reference Vue官网 Vue论坛 Awesome-vue Node Node Article node技巧 NodeJs静态服务器 Reference Reference Node.js 包教不包会 七天学会NodeJS 从零开始nodejs系列文章 Node入门 Node初学者入门，一本全面的NodeJS教程 Gulp Gulp Article Gulp Demo Gulp Reference Gulp官网 Gulp中文网 Gulp资料收集 Gulp：任务自动管理工具 - ruanyifeng Gulp插件 Gulp不完全入门教程 Gulp 入门指南 其他 Other Article 关于Pornographic website的一些前端分析 微信公众号开发 Atom技巧总结 Mac小技巧 CSDN页面内JS跳转脚本 CSDN博客隐藏配置 百度设置小度机器人出现 前端冷知识，妙用浏览器地址栏 Vim笔记 Cordova配置&amp;&amp;Ionic配置（WebApp混合开发环境） IE8及以下按钮超链接无法跳转的问题 分享功能 Share Reference 百度分享(PC) JiaThis(PC) 社会化分享组件(Mobile) ShareSDK轻松实现社会化功能(Mobile) 友盟分享(Mobile) 在线演示 Reference Reference js 在线编辑 - runjs js 在线编辑 - jsbin js 在线编辑 - codepen js 在线编辑 - jsfiddle java 在线编辑 - runjs js 在线编辑 - hcharts js 在线编辑 - jsdm sql 在线编辑 - sqlfiddle mozilla 在线编辑器 富文本编辑器 Reference Reference 百度ueditor ckeditor tinymce kindeditor wysiwyg BachEditor simditor summernote Squire wangEditor Chrome Reference Reference Chrome - 基础 Chrome - 进阶 Chrome - 性能 Chrome - 性能进阶 Chrome - 移动 Chrome - 使用技巧 Chrome - Console控制台不完全指南 chrome开发工具快捷键 Chrome 开发工具 Workspace 使用 Chrome神器Vimium快捷键学习记录 Sass调试-w3cplus 如何更专业的使用Chrome开发者工具-w3cplus Chrome调试canvas 神器——Chrome开发者工具(一) 奇趣百科性能优化(Chrome DevTools 中的 Timeline Profils 等工具使用介绍 Chrome 开发者工具的 15 个小技巧 Chrome开发者工具不完全指南 Chrome 开发者工具使用技巧 性能优化 Reference Reference Javascript高性能动画与页面渲染 移动H5前端性能优化指南 给网页设计师和前端开发者看的前端性能优化 张鑫旭——前端性能 web前端性能优化进阶路 Hey——前端性能 YSLOW中文介绍 Yahoo!团队实践分享：网站性能 加载，不只是少一点点 由12306谈谈网站前端性能和后端性能优化 【高性能前端1】高性能HTML 【高性能前端2】高性能CSS 前端工程与性能优化（上）：静态资源版本更新与缓存 前端工程与性能优化（下）：静态资源管理与模板框架 HTTPS连接的前几毫秒发生了什么 Yslow 阿里无线前端性能优化指南(Pt.1 加载期优化) 毫秒必争，前端网页性能最佳实践 CDN Reference Reference Jquery&amp;Bootstrap中文网开源项目免费 CDN 服务 Bootstrap中文网开源项目免费 CDN 服务 新浪CDN 百度静态资源公共库 开放静态文件 CDN - 七牛 CDN加速 - jq22 微软CDN Angular CDN 360网站卫士常用前端公共库CDN服务 Git Article Article Git操作 Git CSDN Blog Reference Reference Git-scm Git-for-windows 廖雪峰-Git教程 Gogithub Git常规命令练习 Git的资料整理 我所记录的git命令（非常实用） GitHub 漫游指南 GitHub秘籍 动画方式练习git Sass&amp;Less Article Article Less教程 Reference Reference Sass Sass中文文档 Less Markdown Reference Reference Markdown 语法说明 (简体中文版) Markdown入门参考 Mdeditor(一款国内的在线markdown编辑器) Stackedit(国外的在线markdown编辑器，功能强大，同步云盘) Mditor一款轻量级的markdown编辑器 lepture-editor Markdown-editor 前端文档 Reference Reference 前端知识结构 Web前端开发大系概览 免费的编程中文书籍索 前端书籍 前端免费书籍大全 重新介绍JavaScript（JS教程） Gitbook Front-End-Develop-Guide 前端开发指南 前端开发笔记本 大前端工具集 前端开发者手册 结合个人经历总结的前端入门方法 2016最新前端学习计划 前端规范 Reference Reference 通过分析github代码库总结出来的工程师代码书写习惯 HTML&amp;CSS编码规范 by @mdo 前端编码规范之js - by yuwenhui 前端编码规范之js - by 李靖 Airbnb JavaScript 编码规范（简体中文版） AMD与CMD规范的区别 AMD与CMD规范的区别 KISSY 源码规范 前端代码规范及最佳实践 百度前端规范 JavaScript风格指南/编码规范（Airbnb公司版） 网易前端开发规范 前端规范资源列表 Web 前端开发规范文档 前端面试 Reference Reference 2016校招内推 – 阿里巴巴前端 – 四面面试经历 那几个月在找工作（百度，网易游戏，华为） 前端开发面试题 Front-end-Interview-questions 5个经典的前端面试问题 Front-end-Developer-Interview-Questions BAT及各大互联网公司2014前端笔试面试题：JavaScript篇 前端开发面试题大收集 收集的前端面试题和答案 前端开发面试题 前端面试大全 关于前端面试 前端网站 Reference Reference 掘金 百度FEX 阿里UED 菜鸟教程 QDFuns 幕课网 Codepen Sentsin CTOLib CTOLib/Node JS练习 Reference Reference Codewars Javascript-puzzlers Freecodecamp中文版 ES6katas Now Coder牛客网 Leetcode Nodeschool Hackerrank 算法 Reference Reference 数据结构与算法 JavaScript 描述. 章节练习 常见排序算法（JS版） 经典排序 常见排序算法-js版本 ES Reference Reference Exploring-ES6翻译 阮一峰 ES6 ECMA-262，第 5 版 ES5 本文引用自：https://github.com/GuoXingGitHub/Front-end-tutorial","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"工具/插件","slug":"工具-插件","permalink":"http://axss.gitee.io/tags/工具-插件/"},{"name":"web前端","slug":"web前端","permalink":"http://axss.gitee.io/tags/web前端/"}]},{"title":"C#控件属性事件大全","slug":"技术/2018-03-10-csharp控件属性事件大全","date":"2018-03-12T07:00:42.000Z","updated":"2018-03-13T02:58:44.841Z","comments":true,"path":"2018/03/12/技术/2018-03-10-csharp控件属性事件大全/","link":"","permalink":"http://axss.gitee.io/2018/03/12/技术/2018-03-10-csharp控件属性事件大全/","excerpt":"","text":"点击下载 C#控件属性事件大全","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"csharp","slug":"csharp","permalink":"http://axss.gitee.io/tags/csharp/"}]},{"title":"c语言提高6-数据结构,双向循环链表,动态库和静态库","slug":"技术/2015-04-13-c语言提高6-数据结构-双向循环链表-动态库和静态库","date":"2018-03-12T06:49:19.000Z","updated":"2018-03-13T02:58:44.816Z","comments":true,"path":"2018/03/12/技术/2015-04-13-c语言提高6-数据结构-双向循环链表-动态库和静态库/","link":"","permalink":"http://axss.gitee.io/2018/03/12/技术/2015-04-13-c语言提高6-数据结构-双向循环链表-动态库和静态库/","excerpt":"","text":"双向链表双向循环链表和单向链表的区别:1: 双向链表比单向链表多了一个指向前一个节点的指针2: 单向链表的验证结束位置是判断是否为NULL，双向循环链表判断是否结束是判断节点是否跟head节点是否相同，所以我们处理双向链表的时候总是要先保存好头结点 双向链表所有代码事例双向链表所有代码 动态库和静态库动态库和静态库的加载是在链接阶段，因此在链接之前我们只需要提供申明就行，在最后链接上动态或者静态库动态库和静态库: 动态和静态库都是编译好的二进制文件动态库和静态库的标识:.o是静态库 .so是动态库动态库的特点和缺点:动态库在编译的时候没有加载进目标代码中，所以会使动态库所产生的可执行性文件比较小，但是每次程序运行都需要提供对应的动态库，并且同一时间供多个线程调用静态库的特点和缺点:静态库在编译的时候就被加载进了目标代码中，所以会显得产生的可执行性文件会比较大，但是后面运行程序的时候都不用再提供库了，并且同一时间点只能供一个线程用","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"c语言提高5-字符串","slug":"技术/2015-04-13-c语言提高5-字符串","date":"2018-03-12T06:43:46.000Z","updated":"2018-03-13T02:58:44.815Z","comments":true,"path":"2018/03/12/技术/2015-04-13-c语言提高5-字符串/","link":"","permalink":"http://axss.gitee.io/2018/03/12/技术/2015-04-13-c语言提高5-字符串/","excerpt":"","text":"字符串和字符数组sizeof时候的区别在直接sizeof(“字符串”) 字符串的时候，我们此时不能把字符串当作指针来判断，需要将其做为字符数组来看，所以sizeof(“china”) 不等于4而是等于6 字符串字符串n系列函数跟非n函数比较:防止读写越界，所以里面提供了指定的参数来描述我们需要操作的字符数字符串的查询函数:strchr:在一串字符里面，匹配单个字符，存在返回匹配到的数据的地址，否则返回NULLstrstr:在一串字符串里面匹配一串字符，存在则返回匹配到的第一个字符串，否则返回NULL 字符串操作函数代码事例:字符串操作函数代码 内存操作函数特点：只关心读取内容的多少，不关心内容，所以可以过滤掉一些特殊字符12345void * memcpy (void * dst, void const * src, size_t length);void * memmove(void * dst, void const * src, size_t length);void * memcmp (void const * a, void const * b,size_t length);void * memchr (void const * a, int ch, size_t length);void * memset (void * a, int ch ,size_t length); 内存操作函数代码例子:内存操作函数代码 操作字符指针的思想定义两个指针，记录不同的状态值，再根据对应的状态来进行赋值或者其他操作","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"c语言提高4-回调函数,再论指针与数组,基于数组的排序及优化,基于数组的查找及优化,字符串提高","slug":"技术/2015-04-13-c语言提高4-回调函数-再论指针与数组-基于数组的排序及优化-基于数组的查找及优化-字符串提高","date":"2018-03-12T06:33:04.000Z","updated":"2018-03-13T02:58:44.813Z","comments":true,"path":"2018/03/12/技术/2015-04-13-c语言提高4-回调函数-再论指针与数组-基于数组的排序及优化-基于数组的查找及优化-字符串提高/","link":"","permalink":"http://axss.gitee.io/2018/03/12/技术/2015-04-13-c语言提高4-回调函数-再论指针与数组-基于数组的排序及优化-基于数组的查找及优化-字符串提高/","excerpt":"","text":"回调函数理解:回调函数就是用与调用函数同级的函数作为参数从而来控制被调用方函数的逻辑 标准库函数qsort qsort代码例子qsort代码 再论指针与数组12345678910111213141516171819int array[8][8] 二维数组int *ptr 一级指针int * array[10] 指针数组int * p[3][4] 指针数组int (*p)[3][4] 数组指针 int (*p)[3][4]=&gt; int [3][4] * p：所以是个数组指针int (*p[3])[4] 最外层理解：数组指针char * func() 函数char (*func)() 函数指针char (* func[3])() 函数指针数组 int arr[4]; 等价传递 foo(arr,4) foo(int *p, int n)int arr[3][4]; 等价传递 foo(arr,3) foo(int(*p)[4],int n)char *argv[3]; 等价传递 foo(argv,3) foo(int ** argv,int n)//注意传过来的是char*类型char * p; 等价传递 foo(p) foo(char * p)char * p=NULL; 初始化传递 foo(&amp;p) foo(char **p)char **p 等价传递 foo(p) foo(char **p)char **p =NULL; 初始化传递 foo(&amp;p) foo(char *** p)int (*p)[4]; 等价传递 foo(p) foo(int (*p)[4]) //指针数组原先类型就是 int[4]* 所以接收的时候可以直接用void func(int,int); 回调传递 foo(func) foo(void (*p)(int,int)) 数组排序优化版数组排序优化版 qsotr实现二级排序(对结构体)qsotr实现二级排序(对结构体) 字符串字符串常量的本质是一个指针:字符串里面的内容是不能修改的，但是指向字符串的指针变量的是可以修改的例如:char * p=”china”; p是可以修改指向和内容的，但是p所指向的内容是不能修改的数组名的常量:数组名在本作用域内是不能修改的，但是如果将参数名传递到一个新的函数内是可以进行指针偏移的，只是在申明该数组的时候不能进行偏移","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"virtualbox中ubuntu和windows共享文件夹设置","slug":"技术/2018-03-09-virtualbox中ubuntu和windows共享文件夹设置","date":"2018-03-09T12:14:29.000Z","updated":"2018-03-13T02:58:44.821Z","comments":true,"path":"2018/03/09/技术/2018-03-09-virtualbox中ubuntu和windows共享文件夹设置/","link":"","permalink":"http://axss.gitee.io/2018/03/09/技术/2018-03-09-virtualbox中ubuntu和windows共享文件夹设置/","excerpt":"","text":"系统平台系统平台：win8.1、virtualbox4.3.8、ubuntu12.04安装VBoxGuestAdditions_4.3.8.iso增强工具，安装完毕后根据提示重启Ubuntu，具体操作如下： Step 1 Step 2.安装virtualbox增强包123456789101112131415linjiqin@ubuntu:~$ cd ~linjiqin@ubuntu:~$ su -密码： root@ubuntu:~# cd /media/root@ubuntu:/media# lssf_share VBOXADDITIONS_4.3.8_92456root@ubuntu:/media# cd VBOXADDITIONS_4.3.8_92456/root@ubuntu:/media/VBOXADDITIONS_4.3.8_92456# ls32Bit cert VBoxSolarisAdditions.pkg64Bit OS2 VBoxWindowsAdditions-amd64.exeAUTORUN.INF runasroot.sh VBoxWindowsAdditions.exeautorun.sh VBoxLinuxAdditions.run VBoxWindowsAdditions-x86.exeroot@ubuntu:/media/VBOXADDITIONS_4.3.8_92456# sudo ./VBoxLinuxAdditions.run #安装virtualbox增强包....root@ubuntu:/media/VBOXADDITIONS_4.3.8_92456# Step 3先关闭ubuntu，在virtualbox“设置”中找到“共享文件夹”，点击进入，点击右边添加目录按钮，添加windows中要共享的目录，取一个名。比如我在D盘建一个名为share的文件夹，如下图： Step 4重启ubuntu，在ubuntu系统最上端“设备”中找到“共享文件夹”，点击进入，点击右边添加目录按钮，添加第二步操作的共享目录，如下图： Step 5进入虚拟Ubuntu，在命令行终端下输入：sudo mkdir /mnt/sharedsudo mount -t vboxsf share /mnt/shared其中”share”是之前创建的共享文件夹的名字。OK，现在Ubuntu和主机可以互传文件了。要想自动挂载的话，可以在/etc/fstab中添加一项share /mnt/shared vboxsf rw,gid=100,uid=1000,auto 0 0 卸载的话使用下面的命令:sudo umount -f /mnt/shared 注意共享文件夹的名称千万不要和挂载点的名称相同。比如，上面的挂载点是/mnt/shared，如果共享文件夹的名字也是shared的话，在挂载的时候就会出现如下的错误信息：/sbin/mount.vboxsf: mounting failed with the error: Protocol error","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://axss.gitee.io/tags/linux/"},{"name":"windows","slug":"windows","permalink":"http://axss.gitee.io/tags/windows/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://axss.gitee.io/tags/虚拟机/"}]},{"title":"c语言提高3-指针加强,const,函数指针,回调函数","slug":"技术/2015-04-11-c语言提高3-指针加强-const-函数指针-回调函数","date":"2016-04-12T06:17:48.000Z","updated":"2018-03-13T02:58:44.811Z","comments":true,"path":"2016/04/12/技术/2015-04-11-c语言提高3-指针加强-const-函数指针-回调函数/","link":"","permalink":"http://axss.gitee.io/2016/04/12/技术/2015-04-11-c语言提高3-指针加强-const-函数指针-回调函数/","excerpt":"","text":"指针加强1：指针在内存中都是线性的，如果变成二维或者多维空间只是我们在上面强加了一层逻辑而已，所以无论几维的空间我们都可以以一维空间的方式来访问；2：二维数组是一种二维空间，但是二维空间不代表就只能是二维数组，只是二维空间具有二维数组的访问形式 堆上根据二级,三级指针做形参,做返回值来申请二维空间的代码堆上根据二级,三级指针做形参,做返回值来申请二维空间 序列加密的代码序列加密的代码 利用二级指针的方式读取文件到堆内存利用二级指针的方式读取文件到堆内存 const关键字修饰变量不能被修改在左边: 不能修改指向在右边: 不能修改数据*左右都被const修饰: 数据和指向都不能修改 const与defined的区别: const有类型的概念，但是defind没有 const变量定义前必须初始化 函数 函数名的本质: 指向函数体这段代码段的首地址 接收函数名的类型: 返回值 （变量名）（形参类型）；我们可以直接把函数声明拿过来然后把函数名替换成(变量名) 函数指针的申明: 如2直接在变量名加上“[个数]” 回调函数: 调用一个别的方法然后将自己的一个方法名当参数传过去，这样就能将自己的逻辑加在别人的代码里，从而增强灵活性","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"c语言提高2-二维数组,隐式类型转化,数组指针,指针数组,二级指针","slug":"技术/2015-04-10-c语言提高2-二维数组-隐式类型转化-数组指针-指针数组-二级指针","date":"2016-04-10T04:30:13.000Z","updated":"2018-03-13T02:58:44.810Z","comments":true,"path":"2016/04/10/技术/2015-04-10-c语言提高2-二维数组-隐式类型转化-数组指针-指针数组-二级指针/","link":"","permalink":"http://axss.gitee.io/2016/04/10/技术/2015-04-10-c语言提高2-二维数组-隐式类型转化-数组指针-指针数组-二级指针/","excerpt":"","text":"备注备注1强转为int或者char类型则是单纯的数值上的加减，都是每个地址相隔的个数大小，然后每个地址相隔一强转为int*则是地址上的加减，相隔的是每个int的数量 备注2六进制和八进制在字符串中表现的效果： 8进制：”\\0数字数字”：格式是+0后面的八进制数据， 如果说中间出现截断行为（中间出现不是8进制的字符）的话，则后面的都算是单个字符了，注意八进制最多包含0后面两位 16进制：格式：+x+十六进制数表示一个字节：如果说中间出现截断行为（中间出现不是16进制的字符）的话，则后面的都算是单个字符了 12345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void)&#123; char str1[]=\"\\0373xei\";//037算一个字节 后面的依次每个字符算一个字节 //char str1[]=\"\\0383xei\";//03算一个字节 后面的依次每个字符算一个字节 //char str2[]=\"\\x2aet76543\";//x2ae 算一个字节 后面的依次每个字符算一个字节 char str2[]=\"\\x3456aeccaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";//这里只有一个字节因为全部都是十六进制的数据 printf(\"%d\\n\",strlen(str1)); printf(\"%d\\n\",strlen(str2)); return 0;&#125; 类型转化(隐式)小类型与大类型所运算或者逻辑时会默认转化为大类型，有符号的与无符号的会默认转化为无符号的作用：防止数据丢失的一种机制备注：数据本身是没有意义的，只要是要看我们是怎样去解释他1：小类型-&gt;大类型：低位对齐2：大类型-&gt;小类型：低位对齐，改变后注意两个类型的数据的符号是否相同，该过程一定会发生截断行为，但是数据是否丢失，不一定3：有符号-&gt;无符号：注意负数转化为对应的无符号数可能对应一个很大的数（该过程中一定要注意类型），比如int类型的-1例子：这里输出a&lt;b 因为无符号和有符号进行数据或者逻辑运算的时候都会转化为无符号数运算，然后-1的无符号数比a大，所以输出1234567unsigned int a=20;int b=-1;if(a&gt;b)//都会默认转化为无符号数-1的无符号数很大 printf(\"a&gt;b\");else printf(\"a&lt;b\");return 0; 二维数组 理解二维数组或者一维多维数组的地址加减的方法：全部将数组名理解为一维数组来解决，而加减的个数就是步长（类型）的位数 二维数组的在逻辑上理解是平面的，但是在内存上的物理存储是线性的，所以我们可以用线性的（一维）的方式来遍历二维数组，只是改变了类型（步长） 二维数组的传参：行可以少，列不能少 代码二维数组 数组指针指向数组的指针，本质是指针，所以专门用来接收数组的地址1：无论一维还是二维数组名，本质上都是数组指针，只不过是类型不同而已2：指针的运算1：地址的运算其实是计算相隔指定类型的个数2：转化为基本类型则是计算相隔的字节数3：数值指针传参：不管传递几维数组的数组名，我们都可以理解为将该数组的数组指针传递过去4：数组指针型参的推演：int [4] arr (编译不过)=&gt;int arr4=&gt;int (*arr)4 123456789101112#include &lt;stdio.h&gt;//数组指针：定义：本质上都是指针，只不过指向是指向数组//常见的数组指针：不管是几维数组，他们的数组名本质上都是数组指针：常见错误：一级数组取地址等同于数组指针，不是二级指针int main(void)&#123; int array[10]=&#123;1,2,3,4,5,5,6,6,4,5&#125;; int (*p)[10] =array; for(int i =0 ;i&lt;10;i++) printf(\"%d\\n\",array); return 0;&#125; 指针数组数组里面的值都是指针，本质是数组1：备注：我们遍历指针数组的时候常常在数组的末尾加上NULL，用该标识来表示结束2：指针数组的数组名都是二级指针 1234567891011121314151617181920#include &lt;stdio.h&gt;void traveseArray(char ** array,int n)//array就是一个实参的数据 实参是地址 所以该形参也是地址&#123; for(int i=0;i&lt;n;i++) printf(\"%s\\n\",*(array+i));&#125;//常见的处理指针数组的方法 在数组的末尾加上NULL作为结束标识void traveseArray2(char ** array,int n)//array就是一个实参的数据 实参是地址 所以该形参也是地址&#123; while(*array) printf(\"%s\\n\",*(array++));&#125;int main(void)&#123; char * pArray[] = &#123;\"apple\",\"pear\",\"banana\",\"orange\",\"pineApple\",NULL&#125;; traveseArray2(&amp;pArray,5);//指针数组 return 0;&#125; 二级指针指向指针的指针，常用于字符数组1：n级指针可以改变n-1下所有的指针指向和数据2：不管几维数组的指针步长都是4个字节 代码例子二级指针","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"c语言提高1-进程空间,一维数组","slug":"技术/2018-03-09-c语言提高1-进程空间,一维数组","date":"2016-03-24T12:49:16.000Z","updated":"2018-03-13T02:58:44.819Z","comments":true,"path":"2016/03/24/技术/2018-03-09-c语言提高1-进程空间,一维数组/","link":"","permalink":"http://axss.gitee.io/2016/03/24/技术/2018-03-09-c语言提高1-进程空间,一维数组/","excerpt":"","text":"数据类型数据类型的作用在线性的内存中添加一种逻辑操作 补码的特点正数的补码是他本身负数的补码：该负数对应的正数的补码取反加一一个8位的有符号的数据范围为什么是-128到127：因为补码编码的格式不同导致 数据在内存中的意义数据本身是没有意义的，只是要看我们怎样来解释他 类型转化小类型遇到大类型需要转化为大类型，位数不够的话会根据原类型的符号位来补位（是0补0，是1补1）整形遇到浮点型需要转化为浮点型有符号和无符号的运算结果是有符号的转化都是低位对低位进行取值（低位对齐） 进程空间虚拟空间虚拟内存不是我们生活上指的内存条，而是我们通过他来映射到物理内存的一套机制；虚拟内存的好处：早先的电脑是直接将我们运行的程序加载到物理内存中，所以会造成不同的程序直接可以相互调用的后果（很不安全），但是有了这套机制之后，就没有这个缺点了 变量的存放区域总结只要是未初始化的全局或者是静态变量全部储存在data段的未初始化数据段(bss)，默认初始化为0auto的局部变量名无论初始化或者未初始化都储存在栈空间所有的常量都是存储在data区域的只读区域text是储存二进制文件（运行程序）(.exe/.out)的地方 图示 数组以及练习点击查看代码 注意:地址的加减其实是加减地址所指向空间的数量，只有&amp;+数组名才是操作数组的整体","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"c语言16-条件编译","slug":"技术/2015-03-09-c语言16-条件编译","date":"2015-03-30T03:34:12.000Z","updated":"2018-03-13T02:58:44.802Z","comments":true,"path":"2015/03/30/技术/2015-03-09-c语言16-条件编译/","link":"","permalink":"http://axss.gitee.io/2015/03/30/技术/2015-03-09-c语言16-条件编译/","excerpt":"","text":"编译过程预处理-&gt;预编译-&gt;汇编-&gt;链接 宏(define) 宏的后面不用”；”符号，宏只是起的替换的作用，在预处理阶段完成（typedef是在链接的时候完成的） 我们常用比较短并且比较常用的的删除进行宏化，这样嵌入到代码中，减少调用的开销，但是代价就是编译出来的文件会非常大（因为文件中出现了比较多的重复的代码） #: 利用宏来创建字符串（可以达到将其他类型数据嵌入到字符串中） ##: 预处理的粘合剂 预定义宏: 常用语打印日志DATE 进行预处理的日期（“MMmm dd yyyy”形式的字符串文字）FILE 代表当前源代码文件名的字符串文字LINE 代表当前源代码中的行号的整数常量TIME 源文件编译时间，格式“hh: mm: ss”func 当前所在函数名在打印调试信息时打印这两个宏 FILE LINE 可以给开发者非常有用的提示 条件编译单路: #if #endif双路: #if #else #endif多路: #if #elif #elif #endif 头文件包含1: 头文件的内容会被写入到包含该头文件的文件中2: &lt;&gt;（一般用于系统文件）: 系统路径下面找 whereis stdio.h3: “”（一般用于自定义头文件）: 现在当前路径下找 ，找不到再去系统路径下找4: 头文件自包含: 免去多余的前向申明5: 避免头文件被重复包含: #ifndef XX_H #define XX_H //数据类型声明 //函数声明#endif （假设文件名为xx.h）6: c语言是以文件单位进行编译的，编译期只需要函数申明即可，所以我们在给别人接口时候，先给.h（函数的申明文件即可），到时再把.o文件给他进行链接即可","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"c语言15-位操作","slug":"技术/2015-03-09-c语言15-位操作","date":"2015-03-26T03:34:12.000Z","updated":"2018-03-13T02:58:44.801Z","comments":true,"path":"2015/03/26/技术/2015-03-09-c语言15-位操作/","link":"","permalink":"http://axss.gitee.io/2015/03/26/技术/2015-03-09-c语言15-位操作/","excerpt":"","text":"位操作&amp;（清零运算符）：结论：同1与数据不变，同0与清零|（置一运算符）：结论：跟0位或保持不变，与1位或置一^（异或运算符）：结论：对应位相同时清零，不同时置一 掩码(mask)掩码是位操作很重要的一部分，我们可以根据掩码来操作二进制字符里的每一位掩码的功能：1：打开位（置一：flag|mask）；2：关闭位（清零：flag&amp;(~mask)）；3：转置位（位转反：flag^=mask）;4：查看某一位的值 移位左移：低位补零，高位溢出右移：对于有符号和无符号的正整数来说，高位补零，低位溢出；但是对于有符号的负数来说，取决于系统，补零的为“逻辑右移动”，补一的为“算术右移” 二进制文件的加密和解密 特点: 不会溢出 步骤: 根据fread读取文件的每一个字符，然后对每位进行移位操作，然后fwrite写一个新的文件，解密也是如此代码事例:12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;string.h&gt;void encrypt(char * ch1,int num)&#123; int i; for(i=0;i&lt;num;i++) &#123; unsigned char ch=ch1[i]; ch=ch&lt;&lt;1|ch&gt;&gt;7;//char 八位 ch1[i]=ch; &#125;&#125;void decode(char * ch1,int num)&#123; int i; for(i=0;i&lt;num;i++) &#123; unsigned char ch=ch1[i]; ch=ch&gt;&gt;1|ch&lt;&lt;7;//char 八位 ch1[i]=ch; &#125;&#125;//二进制加密文件int main(void)&#123; FILE * fpr=fopen(\"2.wmv\",\"rb+\"); if(NULL==fpr) return -1; FILE * fpw=fopen(\"3.wmv\",\"wb+\"); if(NULL==fpw) return -1; char buff[1024]; int num=0;//read 返回fread读取的数据的长度 while(num=fread((void*)buff,sizeof(char),1,fpr)&gt;0) &#123; decode(buff,num); fwrite((void*)buff,num,1,fpw); &#125; fclose(fpr); fclose(fpw); return 0;&#125; ###总结关于位操作的问题都是需要先求出掩码，然后再根据情况将数据对掩码进行位逻辑运算符操作 将十进制转化为二进制数的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768void binDis(intnum)&#123;inti=32;while(i--)&#123; if(num&amp;1&lt;&lt;i) printf(\"1\");else printf(\"0\");if(i%8==0)&#123; printf(\"\");&#125;putchar('\\n');&#125;//例题：//循环移位void circulation(int*num,intn)&#123;//验证是整数还是负数int m=n&gt;0?n:-n;unsigned int mask=0;while(m--)&#123; mask|=(1&lt;&lt;m); if(n&gt;0) &#123; //做这类题目可以先拿移动一位和10000001来做测试 *num=(*num&lt;&lt;n)|((*num&gt;&gt;(sizeof(*num)*8-n))&amp;mask); &#125; else &#123; //首先右移根据掩码求出数据右移需要清零 *num=(*num&gt;&gt;(-n))&amp;(~(mask&lt;&lt;sizeof(*num)*8-(-n)))|(*num&lt;&lt;sizeof(*num)*8-(-n)); &#125;&#125;//题目： 从键盘上输入 1 个正整数给 int 变量 num， 输出由 3～ 6 位构成的数（ 从低 0 号开始编号）基本思路：1.截取 3~6 位的数， 位移到 0~3 位a)构建 3~6 位上为 1 其余为 0 的数b)位与输入数c)得到的结果右移 3 位2.先将 3~6 位移到 0~3 位， 截取 0~3 位a)输入数右移 3 位b)构建 0~3 位为 1 其余为 0 的数c)位与， 得到结果1： int data=0xaa55;//求出掩码 int mask=1&lt;&lt;7|1&lt;&lt;6|1&lt;&lt;5|1&lt;&lt;4;//让掩码跟数据进行位操作，需要保证我们需要的数据不变data &amp; =mask; //将数据移动到最低位，得到结果data&gt;&gt;=3; 2：int data=0xaa55;data&gt;&gt;=3;int mask=0xf; data&amp;=mask;","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"c语言14-文件操作","slug":"技术/2015-03-09-c语言14-文件操作","date":"2015-03-25T03:34:12.000Z","updated":"2018-03-13T02:58:44.793Z","comments":true,"path":"2015/03/25/技术/2015-03-09-c语言14-文件操作/","link":"","permalink":"http://axss.gitee.io/2015/03/25/技术/2015-03-09-c语言14-文件操作/","excerpt":"","text":"文件操作文本文件操作储存在内存中的都是二进制文件（我们正常输入的数据都是以文本方式储存在内存中的）读取. 将内存中的二进制转化为ascii码，然后将ascii码转化为对应的字符显示写入. 首先将指定的字符转化为ascii码，然后将ascii码转化为2进制储存在内存中 文件字符读取的置位都是先读取完再置位的 feoffeof是先判断标志位是否置位，如果没有置位则继续读，而字符的置位需要先读取才能置位，所以我们使用feof就需要先读取再判断 二进制文件操作读取到的文件都是二进制，写入到内存的数据也是一二进制的方式存储在内存中，所以该效率最快 出现乱码的原因由于编码和解码的格式不同，比如如果我们一开始的文本文件以ascii码的编码格式存入到内存中，然后我们再以解析二进制的格式来解析，就会造成乱码 文件的操作流程硬盘-&gt;开辟一定大小内存的缓存区域-&gt;创建用来描述缓存区域的结构体-&gt;返回结构体指针（根据文件结构体体指针来对文件进行读写操作） 文件三种读取方法代码例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;void myfgetc()&#123; //单字符 /* 1:先赋值再读取 因为文件的置位是先读才会置位的（表示已经读取完了），而feof是根据标志位是否置位的，所以我们需要先读才能用feof来判断是否读取完成 */ FILE * fp=fopen(\"1.txt\",\"r+\"); if(!fp) return -1; char buff; //错误的读取方法 会造成多读一个的效果 // while(!feof(fp))//fgetc和fgets都是返回 // &#123; // buff=fgetc(fp); // printf(\"%c\",buff); // &#125; //1. 第一种验证结束的方法 // while((buff=fgetc(fp))&amp;&amp;!feof(fp))//fgetc和fgets都是返回 // &#123; // printf(\"%c\",buff); // &#125; //2:第二种验证结束的方法 // while((buff=fgetc(fp))!=EOF)//fgetc和fgets都是返回 // &#123; // printf(\"%c\",buff); // &#125; fclose(fp);&#125;void myfgets()&#123; FILE * fp=fopen(\"1.txt\",\"r+\"); if(!fp) return -1; char buff[1024]; while(fgets(buff,1024,fp)!=NULL) //判断结束条件是否为null 遇到'\\0' &#123; printf(\"%s\",buff); &#125; return 0;&#125;void myfread()&#123; FILE * fp=fopen(\"1.txt\",\"r+\"); if(!fp) return -1; char buff[1024]; while(fread((void*)buff,1,1,fp)&gt;0) //注意每次读取的字节数量必须是最小单元，不然如果某次读取的时候没有读满会返回0 也就说明会少打印 &#123; printf(\"%s\",buff); &#125;&#125;int main(void)&#123; return 0;&#125; 读取文件的判断 单字符. 读到文件尾时，返回EOF表示结束 ，也可以借用feof来验证 单行读. 遇到\\n结束一次读取 文本文件的读取和写入方法 rewind: 每次我们写入的时候都会将文件指针移动到写入的最后，但是当我们需要读取文件内容的时候需要重头开始读，所以需要重置文件指针 fputc: 单个字符写入 fgetc: 单个字符读取，根据eof进行判断是否结束 fputs: 多个字符写入 fgets: 多个字符读取，至多读取n-1个字符，最后一个会是’\\0’ feof: 是去读标志位判断文件是否结束的，每验证完一次标志位都会加加 二进制文件的读取和写入: 因为二进制的文件的读取和写入是完全操控二进制的，所以不受影响读取文本文件的字符的影响，所以我们常用该种方法来操作结构体的数据读取和写入 文件操作总结 我们确定是否是最后的最后的节点的时候需要先获取到才能判断，所以我们需要先读，再判断，跟链表相反，链表是直接判断当前节点，而文件是先获取到数据再判断 linux总是会给我们创建的文本文件默认在末尾加上\\n 切记每次操作完文件后，都要释放缓存 清除缓存的方法 fclose \\n fflush(跨平台性不好) fgets和scanf的比较，fgets的安全性比scanf好 fgets的三个参数 stdin stdout stdeorr，fgets遇到’\\n’才结束，所以如果最后一行没有\\n的话会少读一行，并且gets至多只能读n-1个字符，因为最后一个空间要自动补\\0 linux的换行字符是直接\\n windows是\\r\\n 存在平台差异性 二进制文件的读取操作对影响文本文件的读取操作的字符免疫（’\\0’，’\\n’，’\\r\\n’） 操作结构体的数据到文件中，我们用二进制操作会很灵活","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"c语言13-链表","slug":"技术/2015-03-09-c语言13-链表","date":"2015-03-24T12:49:16.000Z","updated":"2018-03-13T02:58:44.793Z","comments":true,"path":"2015/03/24/技术/2015-03-09-c语言13-链表/","link":"","permalink":"http://axss.gitee.io/2015/03/24/技术/2015-03-09-c语言13-链表/","excerpt":"","text":"链表的总结 链表由多个结构组成，每个结构都必须要有一个指向一个和自身大小相同的指针 做链表类型的题目我们需要灵活的保存临时变量来保存指针位置 链表的指针交换的效率一般来讲总是比直接值交换的效率高 头插法和尾插法:头插法的效率比尾插法效率高，因为尾插法的首先需要定位到最后 判断节点是否是最后一个节点:是判断head.next 是否为空 不是判断head 链表的增删查改代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node * next;&#125;Node;//创建链表Node * createHeadNode()&#123; Node * head = (Node*)malloc(sizeof(Node)); Node* cur = NULL; head-&gt;next = NULL; printf(\"请输入您要新增的数据！\\n\"); int data; scanf(\"%d\", &amp;data); while (data) &#123; cur = (Node*)malloc(sizeof(Node)); cur-&gt;data = data; cur-&gt;next = head-&gt;next;//头插法，先为新申请的链表加上地址 head-&gt;next = cur; scanf(\"%d\", &amp;data); &#125; return head;&#125;//新增 尾插入 保存头结点不变Node * createTallNode()&#123; Node * head = (Node*)malloc(sizeof(Node)); Node * pro = NULL; Node* cur = NULL; head-&gt;next = NULL; pro = head; printf(\"请输入您要新增的数据！\\n\"); int data; scanf(\"%d\", &amp;data); while (data) &#123; cur = (Node*)malloc(sizeof(Node)); cur-&gt;data = data; cur-&gt;next = NULL; pro-&gt;next = cur; pro = cur; scanf(\"%d\", &amp;data); &#125; return head;&#125;//查询 获取到链表的长度 不加头结点int getLen(Node * head)//传进来的是&#123; int i = 0; head = head-&gt;next; while (head)//直接接从第第一个开始遍历 &#123; i++; head = head-&gt;next; &#125; return i;&#125;//查询 根据输入的数据返回查找到的指针Node * searchNode(Node * head, int data)&#123; head = head-&gt;next; while (head) &#123; if (head-&gt;data == data) &#123; break; &#125; head = head-&gt;next; &#125; return head;&#125;//删除1 根据指针进行删除数据void delNode(Node * head, Node * delpointer)&#123; // while(head-&gt;next!=findPointer) // head=head-&gt;next; // head-&gt;next=findPointer-&gt;next; // free(findPointer); head = head-&gt;next; while (head-&gt;next != delpointer)//一直遍历 获取到下一个节点是符合数据的指针 &#123; head = head-&gt;next; &#125; head-&gt;next = delpointer-&gt;next; free(delpointer);&#125;//排序 选择排序 数据jiaohuan交换void xzSort(Node * head)&#123; int len = getLen(head); head = head-&gt;next; for (int i = 0; i &lt; len - 1; i++) &#123; Node * temp = head; for (int j = 0; j&lt;len; j++) &#123; //将链表的外层循环跟里面所有的元素比较 if (temp-&gt;data&gt;temp-&gt;next-&gt;data) &#123; temp-&gt;data = temp-&gt;data^temp-&gt;next-&gt;data; temp-&gt;next-&gt;data = temp-&gt;data^temp-&gt;next-&gt;data; temp-&gt;data = temp-&gt;data^temp-&gt;next-&gt;data; &#125; temp = temp-&gt;next; &#125; head = head-&gt;next; &#125;&#125;//排序 选择排序 地址交换void xzSort1(Node * head)&#123; int len = getLen(head); head = head-&gt;next; Node * oldTemp1 = head; Node * oldTemp2 = head; for (int i = 0; i &lt; len - 1; i++) &#123; Node * temp = head; for (int j = 0; j&lt;len; j++) &#123; Node * temp2 = head; if (temp-&gt;data&gt;temp2-&gt;data) &#123; //如果满足条件的话 将两个节点的指针进行交换 首先我们需要获取到两个指针的前一个节点和后一个节点 while (oldTemp1-&gt;next != temp) oldTemp1 = oldTemp1-&gt;next; while (oldTemp2-&gt;next != temp2) oldTemp2 = oldTemp2-&gt;next; Node * newTemp1 = temp-&gt;next; Node * newTemp2 = temp2-&gt;next; oldTemp1-&gt;next = temp2; temp2-&gt;next = newTemp1; oldTemp2-&gt;next = temp; temp-&gt;next = newTemp2; &#125; temp2 = temp2-&gt;next; &#125; temp = temp-&gt;next; &#125;&#125;//排序 冒泡排序 数据交换void mpSort(Node * head)&#123; int len = getLen(head); head = head-&gt;next; for (int i = 0; i &lt; len - 1; i++) &#123; Node * temp = head; for (int j = 0; j&lt;len - i - 1; j++) &#123; //将链表的外层循环跟里面所有的元素比较 if (temp-&gt;data&gt;temp-&gt;next-&gt;data) &#123; temp-&gt;data = temp-&gt;data^temp-&gt;next-&gt;data; temp-&gt;next-&gt;data = temp-&gt;data^temp-&gt;next-&gt;data; temp-&gt;data = temp-&gt;data^temp-&gt;next-&gt;data; &#125; temp = temp-&gt;next; &#125; head = head-&gt;next; &#125;&#125;//排序 冒泡排序 地址交换void mpSort2(Node * head)&#123; Node * sh = NULL; Node * p = NULL; Node * q = NULL; Node *t = NULL; int len = getLen(head) + 1; // head=head-&gt;next;//这里不能直接取下一个节点 因为我们获取到的长度就不包含头结点 for (int i = 0; i &lt; len - 1; i++) &#123; //初始化sh p q 因为冒泡排序都是从0开始排序的 sh = head; p = sh-&gt;next; q = p-&gt;next; for (int j = 0; j&lt;len - i - 1; j++) &#123; if (p-&gt;data &gt; q-&gt;data) &#123; sh-&gt;next = q-&gt;next; &#125; sh = sh-&gt;next; p = p-&gt;next; q = q-&gt;next; &#125; &#125;&#125;//遍历节点void listAll(Node * head)&#123; head = head-&gt;next;//头结点不保存数据 while (head)//没有多加 &#123; printf(\"%d\\n\", head-&gt;data); head = head-&gt;next; &#125;&#125;void myfree(Node * head)&#123; Node * temp=NULL; while (head)//没有多加 &#123; temp = head-&gt;next; free(head); head = temp; &#125;&#125;int main(void)&#123; printf(\"新增----------------\\n\"); Node * head = createTallNode();//返回的节点是头结点 不是头指针 //mpSort2(head); listAll(head); myfree(head); system(\"pause\"); // printf(\"删除----------------\\n\"); // printf(\"请输入您要查找的数据！\\n\"); // fflush(stdin); // int data; // scanf(\"%d\",&amp;data); // Node * temp = searchNode(head,data); // delNode(head,temp);//返回的节点是头结点 不是头指针 // listAll(head); return 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"c语言12-共同体,枚举","slug":"技术/2018-03-09-c语言12-共同体,枚举","date":"2015-03-23T12:49:16.000Z","updated":"2018-03-13T02:58:44.818Z","comments":true,"path":"2015/03/23/技术/2018-03-09-c语言12-共同体,枚举/","link":"","permalink":"http://axss.gitee.io/2015/03/23/技术/2018-03-09-c语言12-共同体,枚举/","excerpt":"","text":"公用体(union) 共用体的申明和结构体一样， 公用体可以嵌套到结构体中，达到一列可以表示不同类型的结果 公用体的大小，由最大的成员空间构成 公用体每一个成员都共同拥有一个首地址，只是因为寻址能力的不同而取到的数据不同，小类型都从低位开始获取数据小端序.就是（栈空间）低位存的是后申请的数据，我们的电脑一般都是小端序大端序.则是低位存的是先申请的数据验证大小端序方法. 验证大小端序的两种方法12345678910111213141516union utest &#123; int num; char num2; &#125;; int main(void) &#123; union utest; t.num = 0x12345678;//储存在栈空间因为栈空间是先申请的在高位（自上向下） //printf(\"%x\\n\",t.num2);//系统帮忙省略了0x if (t.num2 == 0x78) printf(\"小端序！\\n\"); else printf(\"大端序！\\n\"); return0; &#125; 12345int data=0x12345678;if((char)data==0x78)//if(*(char*)(&amp;data))//先获取到data的地址，然后将int*转换成char*，所以取到最后一个字节的空间地址，再取出* printf(\"小端序\");else printf(\"大端序\"); 枚举枚举是一个整形的常量集合，给前面的一个变量赋值一个数值，后面的变量会逐一加一","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"c语言11-进程空间,结构","slug":"技术/2015-03-09-c语言11-进程空间-结构","date":"2015-03-21T16:16:12.000Z","updated":"2018-03-13T02:58:44.790Z","comments":true,"path":"2015/03/22/技术/2015-03-09-c语言11-进程空间-结构/","link":"","permalink":"http://axss.gitee.io/2015/03/22/技术/2015-03-09-c语言11-进程空间-结构/","excerpt":"","text":"进程空间ree:释放空间的时候 保存指针的变量还是不变的，释放的只是保存数据的空间，所以我们还可以通过该指针变量来访问数据，可能该空间重新保存了别的数据，所以释放后我们也需要将指针变量设置为NULL，避免通过该指针非法访问导致系统崩溃 申请，判空，使用，释放，置NULL 在自定义方法里面申请栈空间返回地址时特别注意:栈里的空间不能返回，也就是说不能通过返回栈空间的地址的方式访问栈空间，但是堆空间是可以返回的，也就是说可以通过堆空间返回的地址来操作堆空间 内存泄漏申请返回的指针，是我们操作堆空间唯一的标识，如果该标识丢了，那么就会造成内存泄漏 malloc和free: malloc的个数大雨free导致内存泄漏 free大于malloc出现double free free和malloc必须配对使用 进程空间和程序之间的关系每个程序启动都会开辟一个新的进程空间，所以进程空间和程序是一对一的关系 申请内存时易犯错的三点malloc申请内存判断是否申请失败1234char * ch=(char*)malloc(100); if(NULL==ch) return -1; free(ch); 服务器模型:未释放内存空间，重新开辟新的空间，导致内存泄漏while(1){ charch=(char)malloc(100); printf(“xxxxxxxxxxxxxxxx\\n”); printf(“xxxxxxxxxxxxxxxx\\n”); printf(“xxxxxxxxxxxxxxxx\\n”); ch=(char*)malloc(100);//中途忘记已经是申请了导致重新开辟了一个新的空间 free(ch);//每次循环都只是释放了一个空间还剩下一个空间没有释放导致越来越多的内存泄漏（没有释放）} 内存空间最好谁申请谁释放(非绝对)自实现栈空间模型的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;//FILO LIFO#define N 100struct Stack&#123; char space[N]; int top;&#125;;struct Stack st = &#123;&#123;0&#125;,0&#125;;int isFull() //满返真&#123; if(st.top == 100) return 1; else return 0;&#125;int isEmpty() //空返真&#123; if(st.top == 0) return 1; else return 0;&#125;void push(char ch)&#123; st.space[st.top] = ch; st.top++;&#125;int pop()&#123; st.top--; return st.space[st.top];&#125;int main(void)&#123; char ch = 'a'; for(int i=0; i&lt;26; i++) &#123; if(!isFull()) push(ch++); &#125; while(!isEmpty()) putchar(pop()); return 0;&#125; 结构体使用情景结构体设计出来就是为了处理我们在一个情况下需要处理多种不同类型而设计出来的，可以自定义类型的方法 内存对齐 结构体的几种定义方式1.无名构造体:struct{}stu;:仅在本地使用，并且申明的时候必须带上变量名2.有名构造体:struct 结构体名{}stu; 申明变量:struct 结构体名 变量名3.别名构造体类型:typedef struct 结构体名{} 别名; 以后 别名=struct 结构体名 小结1:我们定义的新类型，只要没有申明变量是步占空间的2:结构体的类型是 struct+结构体名，struct不能省悦3:凡是基本类型都可以先申明后初始化，或者直接在申明的时候初始化,凡是构造类型必须在申明的时候初始化，或者先申明然后对单独的每个“元素”单独初始化，例如:如果是二级数组在先申明后初始化应该对[][]的每个元素单独初始化4:切记，数组名是数组元素的首地址，是个常量，不能修改，所以我们对字符数组进行赋值的时候不能直接将字符串用=的符号进行复赋值（接收数据的变量是个指针（字符数组首元素的指针（常量）），应该用strcpy进行赋值操作5:结构体做形参，实参，返回值，接收值时，都是用结构体类型6:typedef:申明别名的方法 例:typedef 类型 别名（别名我们一般用大写，和系统的类型进行区分）7:结构体数组如果未初始化，不设值的会默认为0（整形的为0，字符型的为’\\0’，ascii码为0）8:如果结构体中有数组的话需要把数组散开看，再来拿出最大值，不能把整个数组一起看","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"c语言10-字符串和命名空间","slug":"技术/2015-03-09-c语言10-字符串和命名空间","date":"2015-03-19T16:04:29.000Z","updated":"2018-03-13T02:58:44.789Z","comments":true,"path":"2015/03/20/技术/2015-03-09-c语言10-字符串和命名空间/","link":"","permalink":"http://axss.gitee.io/2015/03/20/技术/2015-03-09-c语言10-字符串和命名空间/","excerpt":"","text":"c语言里面的字符串理解:1:因为c语言中没有字符串类型，所以只能用char类型的数组来代替， 2:在编译阶段，系统会将字符串编译加载到data空间的只读区域，以字符数组的方式存放，并且字符串就相当于是数组名（字符串元素的首地址）【常量不能修改】 3:注意:字符串的首地址是个常量，不能修改和移动的，因为如果修改了首地址的话，后面的其他元素也就找不到了，如果我们要修改的化，可以将首元素的地址复制到一个新的char*类型变量中，然后根据这个新的指针变量来进行修改操作 4:一串字符的结束标识是’\\0’ascii码为0，我们正常输入的字符的ascii码范围为32~127，我们常用这个作为验证字符串是否结束 5:没有’\\0’的字符串不能称为字符串，只能称作字符数组 6:用char数组来申明字符串的时候，我们可以利用数组可以省阅长度的特点来申明变量 7:c语言中对字符串进行排序是先比较长度，如果长度相同再将其转换为ascii码单个字符进行比较的，所以strmp就是这样实现的 c语言中常用的字符串标准库函数:头文件string.h123456gets:可以获取到屏幕中的字符串，在遇到回车才会停止，遇到空格也会加载（scanf遇到空格会结束自动加上\\0）puts:往屏幕追加字符strlen（求字符串长度）:size_t strlen ( const char * str );strcat（将两个字符串叠加）:char * strcat ( char * dest, const char * src );strcpy（将字符串完全复制到一个新的字符数组中）:char * strcpy ( char * dest, const char * src );strcmp（比较两个字符串的大小）:int strcmp ( const char * str1, const char * str2 ); 多文件编程注意:我们需要在头文件加上#ifndefCP_H #defineCP_H #endif//CP_H 的作用是防止头文件冲突 指针数组理解:指针数组的本质就是数组，只不过里面存储的是指针（字符数组名），当我们要传递指针数组时，形参和实参的类型应该为二级指针 内存空间理解:1:我们说的内存空间不是我们说的内存条，而是虚拟内存（总的内存=系统内核空间+用户空间）的用户空间部分 2:我们开发中常用的两部分内存，栈空间和堆空间:栈空间:自上向下发展，先申请的为高位，后申请的为低位3:我们每运行一个程序都会开辟一个新的进程空间，每个进程空间现在可以理解为独立的特点:随用随开，用完即销；堆空间:自下向上发展:先申请的为低位，后申请的为高位，对于栈来说，无限大，但在实际开发中，受限于是否连续空间c语言中申请内存空间的函数:头文件 stdlib.h特点:申请的都是堆空间注意:每次申请都要记得释放malloc:void malloc(size_t _Size);calloc:void calloc(size_t nmemb, size_t size);:开辟nmemb个size大小的空间realloc:void realloc(void ptr, size_t size); :根据原有空间来扩容，先直接在原有空间后面找，看是否有size大小的空间，如果有就直接创建，如果没有，会去其他地方找，找到后会将原空间的内容复制进去，并且返回新的地址free:void free(void *p); 数组指针传递以及二级指针接收的流程概括 自实现c语言常用字符函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//1:myStrlen:void myStrLen( char*str1 )&#123; int num = 0; while (*str1++) /* 验证完了再加加如果符合才进 */ &#123; num++; &#125; printf( \"%d\\n\", num );&#125;//2:myStrCat:void myStrCat( char*str1, char*str2 )&#123;/* 首先将首空间的地址储存 */ char*newStr = str1;/* 将首空间的地址移动到空间的最后 */ for (; *str1; str1++ );/* 将要追加的内容进行追加 */ for (; *str1 = *str2; str1++, str2++ ); printf( \"%s\", newStr );&#125;//3:myStrCmpint myStrCmp( char*str1, intnum1, char*str2, intnum2 )&#123; if(num1&gt;num2) return 1; else if(num1 &lt; num2 ) &#123; return(-1); &#125;else &#123; while ( 1 ) &#123; if ( *str1 &gt; *str2 ) return1; else if( *str1 == *str2 &amp;&amp; *str1 == '\\0' &amp;&amp; *str2 == '\\0' ) return0; else if( *str1 &lt; *str2 ) return(-1); str1++; str2++; &#125; &#125;&#125;//4:myStrCopy:void myStrCpy( char*str1, char*str2 )&#123; char * newStr = str2; for (;*str2 = *str1; str1++, str2++ ); printf( \"%s\\n\", newStr );&#125;//5:对字 符 串 数组进行排序:void myStrSort( char**str1, intnum )&#123; for ( inti = 0; i &lt; num; i++ ) &#123; for ( intj = 0; j &lt; num - i - 1; j++ ) &#123; if ( strcmp( *(str1 + j), *(str1 + j + 1) ) &gt; 0 ) &#123; char*temp = *(str1 + j); *(str1 + j) = *(str1 + j + 1); *(str1 + j + 1) = *(str1 + j); &#125; &#125; &#125; for ( inti = 0; i &lt; num; i++ ) printf(\"%s\\n\", *(str1 + i));&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"c语言9-变量作用域及修饰符","slug":"技术/2015-03-09-c语言9-变量作用域及修饰符","date":"2015-03-19T15:41:56.000Z","updated":"2018-03-13T02:58:44.809Z","comments":true,"path":"2015/03/19/技术/2015-03-09-c语言9-变量作用域及修饰符/","link":"","permalink":"http://axss.gitee.io/2015/03/19/技术/2015-03-09-c语言9-变量作用域及修饰符/","excerpt":"","text":"修饰符关键字auto修饰局部变量，所有的局部变量的默认修饰符，然后因为数据是存储在栈空间（系统随机分配），所以如果不初始化变量，会产生一段随机的内容 register修饰局部变量，被修饰的变量数据会存储在cpu的寄存器，从而达到提高处理效率的能力，但是注意cpu寄存器的数量有限，所以我们一般不使用，如果不初始化变量，会产生一段随机的内容，一般用于多文件编程，但是也容易造成命名污染，但是用static可以解决，因为被static修饰的变量只能作为该文件的全局变量 备注:一般被register修饰的变量在优化期间，可能会自动处理成auto extern修饰全局变量，被修饰的变量，可以在变得文件使用，作用发生在链接时期 static修饰全局或者静态变量，修改了变量的生命周期，使变量的生命周期变成从程序启动到程序结束，并且变量只能被初始化一次，如果未初始化，系统会默认将变量的数据设置为0，注意被static修饰的变量存储的区域和其他变量存储的区域不同，所以我们可以将被static修饰的变量当作缓存使用","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"c语言8-函数","slug":"技术/2015-03-09-c语言8-函数","date":"2015-03-18T15:41:56.000Z","updated":"2018-03-13T02:58:44.808Z","comments":true,"path":"2015/03/18/技术/2015-03-09-c语言8-函数/","link":"","permalink":"http://axss.gitee.io/2015/03/18/技术/2015-03-09-c语言8-函数/","excerpt":"","text":"指针偏移法使用范围：只针对连续的空间，不然指针偏移没有任何意义！因为指针的加减其实就是获取到该指针对应的数组的步长的加减！一级指针：公式推到：arr[i]=i[arr]=(arr+i) arr的数组的步长为int二级指针：公式推到：arr[i][j]=(*(arr+i)+j) arr的数组的步长为int[j] arr[j]的数组的步长为int 函数的返回值c语言的返回值只有基本类型和指针类型，没有其他类型 将数组作为参数传递1.传递首元素指针和数组元素的数量2.*(arr+i)==arr[i]==i[arr] 递归理解:其实就是方法自己调用自己，到达某一时刻后return，返回数据公式结构和书写结构: 获取一个范围内的随机数的方法123456789101112131415161718192021int randomNum(intm,intn)&#123; srand(time(NULL)); intnum=rand(); intresult=num%(n-m)+m+1;//获取到m到n之间的随机数 printf(\"%d\\n\",result);&#125;//产生30个不重复的随机数放到指数组中去。intarr[10];srand(time(NULL));inti=0;while(i&lt;30)&#123; intnum=rand()%(50-30)+30+1; intresult=searchArr(arr,sizeof(arr)/sizeof(arr[0]),num); if(!result) continue; else arr[i++]=num; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"c语言7-指针","slug":"技术/2015-03-09-c语言7-指针","date":"2015-03-17T15:41:56.000Z","updated":"2018-03-13T02:58:44.807Z","comments":true,"path":"2015/03/17/技术/2015-03-09-c语言7-指针/","link":"","permalink":"http://axss.gitee.io/2015/03/17/技术/2015-03-09-c语言7-指针/","excerpt":"","text":"内存我们计算机的所有内存都是线性的，不管是一维数组还是二维数组在内存中都是线性的，内存线性是物理基础（不要问我） 机器的不同，导致指针类型的大小不同，32位机的指针类型是4个字节，64位机的指针大小是8个字节，而位数的多少又影响到地址总线的宽度，导致最大支持的内存大小（内存条），所以32位机支持的最大的内存条是4g，并且4g有一部分被其他硬件占用，所以剩3g多来给用户使用，地址总线越宽，同一时间传输的地址数据就越多，从而达到同一时间可以让跟多的软件来访问内存，起到同一时间可以运行更多的软件 十六进制的解释一个十六进制位数表示4个二进制位数，我们为一个变量赋一个16进制数和一个10进制数的表达方式是一样的，只不过打出的数据不同，十六进制的读操作：因为我们的电脑是4个二进制对应一位16进制的数，所以我们内存里的一个存储单元可以存储两位16进制的数，并且我们根据指针读数据都是从低位向高位读取，并且每个变量保存的都是首地址，所以:1234inta=0x0355;int*a1=(int*)&amp;a;//355char*a2=(char*)&amp;a;//55 拿到低位地址 根据类型（寻址能力）向上找到数据后用数据总线返回cpushort*a3=(short*)&amp;a;//355 0会被忽略 从大类型转换为小类型数据截取的解释我们的数据在内存条中都是线性存储的并且占时的内存大小是从大到小的 但是我们此时的首地址是不变的，只是寻址能能力变化了 例如 int a=0x12345678 char p=(char)a printf(“p=%x”); p=78 指针和地址的区别指针是一个有类型的地址，所以我们可以根据地址来设置地址偏移来获取数据备注:我们变量保存的都是首地址（当前数据空间最小的地址），然后根据数据类型来去从首地址拿指定个数的空间数据（因为现在我首地址和类型（空间个数）和每个空间的大小（8位）都确定了 所以我们可以按照规律取出数据） *：根据地址取内容 前提要有地址&amp;：根据变量取地址，如果对象是数组的话我们根据他取到的是数组的整体 自定义地址(危险)直接为一个指针变量赋一个我们自己写的值的画很危险，因为我们随机写的地址可能是系统内核占用的，所以可能影响到系统，所以我们申请内存一般都是需要系统帮我申请，而不是自己随机写地址，一般4g的内存的话 0~3g为用户内存，3g~4g为系统内存，所以3g~4g的地址我们是不能申请的 同类型数据加减的问题同类型相减等于相隔空格数，基本类型除外 数组和指针的关系数组名是个常量 不能修改 不能进行加减计算*p++ 先算++ 再去值一级数组和指针的关系：a+1表示 数组的首地址和数组元素的首地址之间的关系“指针”加数值，加的是该对象对应的数组的步长数组的整体和元素性：对数组加上&amp;就是表述数组的整体性123456789101112131415intarr[3][4]=&#123;1,2,3,4,10,20,30,40,100,200,300,400&#125;; //T arr[3]printf(\"arr=%p\\n\",arr+1);//arr的数组的步长为int[4]所以加的是int[4]的字节大小printf(\"&amp;arr=%p\\n\",&amp;arr+1);//表示数组的整体，所以步长为整个数组，所以加的是整个数组的长度printf(\"&amp;arr[0]=%p\\n\",arr[0]+1);//arr[0]这里不是表示地址 而是取值 不考虑printf(\"&amp;arr[0]=%p\\n\",&amp;arr[0]+1);//&amp;arr的数组的步长为int[4]，所以加的是int[4]的字节大小intarr[5]=&#123;10,20,30,40,50&#125;; printf(\"arr[0]=%p\\n\",arr[0]);//这里是直接取值 不是指针 不考虑 直接加一printf(\"&amp;arr[0]=%p\\n\",&amp;arr[0]);//&amp;arr的数组的步长为int所以加上int类型大小printf(\"arr[0]+1=%p\\n\",arr[0]+1);//这里是直接取值 不是指针 不考虑 直接加一printf(\"&amp;arr[0]+1=%p\\n\",&amp;arr[0]+1);//&amp;arr的数组的步长为int所以加上int类型大小printf(\"&amp;arr+1=%p\\n\",&amp;arr+1);//&amp;考虑的是整体性 直接加上int[5]的类型大小printf(\"&amp;arr[0]=%p\\n\",&amp;arr[0]);//&amp;arr[0]的数组的步长为int 所以直接加intprintf(\"&amp;arr+1=%p\\n\",&amp;arr+1);//整体 直接加int[4] 指针类型变量的二义性1int * p1=&amp;a; //p1：表示的是a的地址；&amp;p1表示的是p1变量本身的地址 根据指针偏移遍历集合的方法12345678910111213int arr[5]=&#123;10,20,30,40,50&#125;;for(inti=0;i&lt;5;i++)printf(\"%d\\n\",arr[i]);printf(\"--------------\\n\");for(inti=0;i&lt;5;i++)printf(\"%d\\n\",i[arr]);printf(\"--------------\\n\");for(inti=0;i&lt;5;i++)printf(\"%d\\n\",*(arr+i));//arr+iarr的类型为int所以偏移int的i位printf(\"--------------\\n\");int*p=&amp;arr;for(inti=0;i&lt;5;i++)printf(\"%d\\n\",*p++);//先算p++结果为*p后++ a[i]=*(a+i) *也起到降级别的能力","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"c语言5-数组的二义性","slug":"技术/2015-03-09-c语言5-数组的二义性","date":"2015-03-15T15:41:56.000Z","updated":"2018-03-13T02:58:44.806Z","comments":true,"path":"2015/03/15/技术/2015-03-09-c语言5-数组的二义性/","link":"","permalink":"http://axss.gitee.io/2015/03/15/技术/2015-03-09-c语言5-数组的二义性/","excerpt":"","text":"数组的二义性数组名的二义性数组名的二义性:整体性和个体性整体性用的很少情况 一般只有在我们求sizeof的时候才是当我们用数组名当作地址的时候都是体现数组的元素性 指针运算指针与数值：加减都是该指针指向空间的n的倍数（加减n）例子：int arr[3]={0}; arr：arr是数组第一个元素的首地址，表示数组的个体性，并且该指针指向的空间为int类型，所以加减为int的倍数 &amp;arr[0]：arr与&amp;arr[0]这两个指针相同，并且指向的空间也一样，都是int类型大小，所以&amp;arr[0]加减也是加减int的倍数 int arr[3][4]={}; 我们需要将该数组转换成一维数组来看 =int[4] arr[3] =T arr3 arr：arr是该数组的第一个元素的第一个指针，指向的空间大小为int[4] &amp;arr[0]：arr和&amp;arr[0]这两个的指针相同，并且都指向一个T（int[4]）的空间，所以加减都是int[4]的倍数 &amp;arr[0][0]：&amp;arr[0][0]是一个二维数组里面的一个一维数组里面的第一个指针，并且所指向的空间大小为int，所以加减int的倍数 我们将指针赋值给一个新的指针变量，新的指针变量的类型也就是该指针指向空间大小，然后加上，总结出，指针变量的类型（除掉）和指向空间的类型相同","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"c语言4-程序的设计结构","slug":"技术/2015-03-09-c语言4-程序的设计结构","date":"2015-03-14T15:41:56.000Z","updated":"2018-03-13T02:58:44.806Z","comments":true,"path":"2015/03/14/技术/2015-03-09-c语言4-程序的设计结构/","link":"","permalink":"http://axss.gitee.io/2015/03/14/技术/2015-03-09-c语言4-程序的设计结构/","excerpt":"","text":"程序的设计结构do while的特点：先做处理再判断，常用于登录的一系列验证for的特点：先加加索引在判断break：结束当前循环（相对break最里面的）continue：跳出当前循环的这次循环（相对于continue最里面的）return：结束所有循环，以及释放该方法所占的空间（表示所处的函数结束）","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"c语言3-优先级","slug":"技术/2015-03-09-c语言3-优先级","date":"2015-03-13T15:32:22.000Z","updated":"2018-03-13T02:58:44.805Z","comments":true,"path":"2015/03/13/技术/2015-03-09-c语言3-优先级/","link":"","permalink":"http://axss.gitee.io/2015/03/13/技术/2015-03-09-c语言3-优先级/","excerpt":"","text":"运算表达式常让人混淆的表达式： 所有的常量表达式都是可以做判断的 3==3==3；得到的是0 就是两个判断 无论在if的时候判断的表达式有多长，判断的都是最左边的变量是为0还是1 例题: 判断是否是回文数1234567891011121314151617long long var;printf(\"pls input num:\\n\");scanf(\"%lld\", &amp;var);long long sum = 0;long long m = var;//倒置var循环12321 1 1232 12 123 3while (m) &#123; sum = m%10 + sum*10; m /= 10; // 循环条件&#125;if(var == sum) // 判断输入var与倒置sum是否相等&#123; printf(\"%d是回文\\n\", var);&#125;else &#123; printf(\"%d不是回文\\n\", var);&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"c语言2-补码","slug":"技术/2015-03-09-c语言2-补码","date":"2015-03-12T15:16:39.000Z","updated":"2018-03-13T02:58:44.802Z","comments":true,"path":"2015/03/12/技术/2015-03-09-c语言2-补码/","link":"","permalink":"http://axss.gitee.io/2015/03/12/技术/2015-03-09-c语言2-补码/","excerpt":"","text":"流程图简要椭圆：开始/结束平行四边行：输入陵行：判断矩行：操作 类型介绍备注：为什么正数数值范围都是2的多少次方减1：因为由于补码规则可知，同一个补码可能表示一个正数也可能表示一个负数，所以为了避免这种歧义，就规定了补码的最高位为符号位，这样以来一个补码就对应一个正数了，但是+0和-0都是0 比如：八位二进制的正数最大值是 1111 1111 = 2^8-1 (数列) 0111 1111 2^7-1 命名规范物理基础 cpu在运作时，读取内存数据，首先要指定存储单元的地址，就是要确定读写哪段数据。即要明确三件事a. 存储单元地址（地址信息）b. 器件的选择，读or写（控制信息）c. 读写的数据（数据信息） 地址总线：cpu通过地址总线告诉内存我们需要操作指定的空间 数据总线：cpu 通过数据总线实现与内存的数据交互 控制总线：cpu对其他硬件设备发出需要对其进行的操作（读/写）的命令 补码概念：在计算机系统中，数值一律用补码来表述或者存储，原因在于，可以将符号和数值域统一处理；同时加法和减法也可以统一处理此外，补码和原码的运算过程是相同的，不需要额外的硬件电路 备注： 补码都是二进制，以及计算机下面的所有储存地址还是数据都是补码，为什么我们看到的不同，是因为我们的ide或者cpu进行过特殊处理，因为如果全部用二进制显示会得到一串我们很难分析的字符 原码都是十进制，所以将补码转化为源码其实就是将二进制转化为十进制 正数的源码就是他本身，负数的源码是”求反加一“，负数的源码求反码也是如此 补码解决了三件事情：a. 解决了正负零的问题b. 解决了符号参加运算的问题c. 实现了减法，乘法，除法都变加法的问题 ASCII码ascii码的显示效果就是cpu操作显卡的结果例如:97是a的asscii码，转换成ascii码的时候需要先将97转换为补码(二进制) 16进制我们保存16进制数据时其实是直接将16进制的数据保存到了内存中，不像十进制会进行补码操作，%x因为输出的是16进制，所以每次输出都要满4个字节，如果前面的数据为0他是省略的，但是并不表示他是没有的，如果前面位数不够，会根据符号位来进行补位操作，如果符号位是0就把前面的都补0知道补满为止例子： short类型 0x8756 用%x输出是ffff8756理解：1：首先我们需要确认数据的类型，因为数据的类型是short，（如果是int就没必要补位了，因为肯定是正数，最高位（符号位）是第32位，是0，省略了） ，所以我们取到short的最高的符号位（第16位/2个字节），就是8的补码的最高位，1000，所以前面是1那么前面全部补1，知道补满32位 然后每四个1就是一个f（因为是16进制输出），所以就得到1111 1111 1111 1111 所以就得到ffff8756 总结根据十六进制来保存数据时，其实是直接将16进制保存到内存中，不像10进制会进行补码操作补位补位步骤: 确定类型 根据类型确定最高位（符号位） 根据符号位来进行补位，知道补满（根据我们是要输出16进制还是8进制还是10进制来判断）为止（如果是1则补1，如果是0则补0）","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"c语言1-c程序的处理过程","slug":"技术/2015-03-01-c语言1-c程序的处理过程","date":"2015-03-11T15:16:39.000Z","updated":"2018-03-13T02:58:44.788Z","comments":true,"path":"2015/03/11/技术/2015-03-01-c语言1-c程序的处理过程/","link":"","permalink":"http://axss.gitee.io/2015/03/11/技术/2015-03-01-c语言1-c程序的处理过程/","excerpt":"","text":"c程序的处理过程预处理–&gt;预编译–&gt;汇编–&gt;链接；备注：.o文件为二进制文件 步骤解析 vim hello.c gcc -E hello.c -o hello.i //处理文件包含， 宏和注释 gcc -S hello.i -o hello.s //编译为汇编文件 gcc -c hello.s -o hello.o //经汇编后为二进制的机器指令 gcc hello.o -o hello //链接所用的到库","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://axss.gitee.io/tags/c语言/"}]},{"title":"SBC大数据导入(代码)","slug":"技术/2018-03-09-SBC大数据导入(代码)","date":"2013-07-13T12:46:25.000Z","updated":"2018-03-13T02:58:44.818Z","comments":true,"path":"2013/07/13/技术/2018-03-09-SBC大数据导入(代码)/","link":"","permalink":"http://axss.gitee.io/2013/07/13/技术/2018-03-09-SBC大数据导入(代码)/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381using System;using System.Collections.Generic;using System.Text;using System.Data;using System.IO;using System.Threading;using System.Web;using System.Xml;using System.Configuration;using System.Data.SqlClient;using WXMP.WinService.Data;namespace Utility.DataImport&#123; public class TxtImport &#123; /// &lt;summary&gt; /// 导入数据 /// &lt;/summary&gt; /// &lt;param name=&quot;fileName&quot;&gt;文件名&lt;/param&gt; /// &lt;param name=&quot;columnCount&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;xmlTableName&quot;&gt;xml配置名&lt;/param&gt; /// &lt;param name=&quot;RealTableName&quot;&gt;数据库表名称&lt;/param&gt; /// &lt;param name=&quot;defaultValue&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;ConnectionKeyName&quot;&gt;数据库连接配置&lt;/param&gt; /// &lt;param name=&quot;heardRowCount&quot;&gt;文件头定义行数&lt;/param&gt; /// &lt;param name=&quot;footRowCount&quot;&gt;文件尾定义行数&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static int ImportData(string fileName, string xmlTableName, Dictionary&lt;string, object&gt; defaultValue, string ConnectionKeyName = &quot;default&quot;, int heardRowCount = 0, int footRowCount = 0) &#123; if (fileName == &quot;&quot;) return 0; return Insert(fileName, xmlTableName, defaultValue, ConnectionKeyName, heardRowCount, footRowCount); &#125; /// &lt;summary&gt; /// 导入文本文件 /// &lt;/summary&gt; /// &lt;param name=&quot;fileFullName&quot;&gt;文本全路径&lt;/param&gt; /// &lt;param name=&quot;columnCount&quot;&gt;文本里需要导入的列的数目&lt;/param&gt; public static int Insert(string fileFullName, string xmlTableName, Dictionary&lt;string, object&gt; defaultValue, string ConnectionKeyName, int heardRowCount = 0, int footRowCount = 0) &#123; string exesql = string.Empty; string tablename = string.Empty; DataTable dt = XmlToDataTable(xmlTableName, out tablename, out exesql); if (dt != null) &#123; LoadAdpaterDataAndImport(fileFullName, dt.Columns.Count, dt, defaultValue, ConnectionKeyName, tablename, heardRowCount, footRowCount); DbHelper.ExecuteNonQuery(exesql, ConnectionKeyName); return dt.Rows.Count; &#125; return 0; &#125; /// &lt;summary&gt; /// /// &lt;/summary&gt; /// &lt;param name=&quot;fileFullName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;columnCount&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;pDTScheme&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;defaultValue&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;connectionName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;realTableName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;heardRowCount&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;footRowCount&quot;&gt;&lt;/param&gt; public static void LoadAdpaterDataAndImport(string fileFullName, int columnCount, DataTable pDTScheme, Dictionary&lt;string, object&gt; defaultValue, string connectionName, string realTableName, int heardRowCount = 0, int footRowCount = 0) &#123; try &#123; using (StreamReader sr = new StreamReader(fileFullName, Encoding.Default, true)) &#123; string strTmp; DataRow dr; int i = 0; while (!sr.EndOfStream) &#123; strTmp = sr.ReadLine(); if (string.IsNullOrEmpty(strTmp)) continue; i++; if (i &lt;= heardRowCount) continue; heardRowCount = 0; dr = GetDataRow(strTmp, columnCount, pDTScheme, defaultValue); if (dr != null) pDTScheme.Rows.Add(dr); if (i % 100000 == 0) &#123; UseSBCInsertDB(connectionName, pDTScheme, realTableName, 9000, true); pDTScheme.Rows.Clear(); i = 0; Thread.Sleep(1000); &#125; &#125; if (pDTScheme.Rows.Count &gt; 0) UseSBCInsertDB(connectionName, pDTScheme, realTableName, 9000, true); DbHelper.ExecuteNonQuery(@&quot;INSERT INTO dbo.T_R01_FileLoadInfo(ImpName,LoadTime,RecordCount,LoadStatus)VALUES(&apos;&quot; + fileFullName.Substring(fileFullName.LastIndexOf(&quot;\\\\&quot;) + 1) + &quot;&apos;,&apos;&quot; + DateTime.Now.ToString(&quot;yyyyMMddHHmmss&quot;) + &quot;&apos;,&apos;&quot; + (i - heardRowCount - footRowCount).ToString() + &quot;&apos;,&apos;0&apos;);&quot;, connectionName); &#125; &#125; catch (Exception ex) &#123; DbHelper.ExecuteNonQuery(@&quot;INSERT INTO dbo.T_R01_FileLoadInfo(ImpName,LoadTime,RecordCount,LoadStatus)VALUES(&apos;&quot; + fileFullName.Substring(fileFullName.LastIndexOf(&quot;\\\\&quot;) + 1) + &quot;&apos;,&apos;&quot; + DateTime.Now.ToString(&quot;yyyyMMddHHmmss&quot;) + &quot;&apos;,&apos;&apos;,&apos;3&apos;);&quot;, connectionName); Utility.Logging.Log.Instance.Write(&quot;读取文件发生异常&quot; + ex.Message, Logging.MessageType.Error); &#125; &#125; protected static DataRow GetDataRow(string strTmp, int columnCount, DataTable pDTScheme, Dictionary&lt;string, object&gt; defaultValue) &#123; string[] result = strTmp.Split(new string[] &#123; &quot;&amp;&amp;&quot; &#125;, StringSplitOptions.None); DataRow dr = null; if (result.Length &gt;= columnCount) &#123; dr = pDTScheme.NewRow(); for (int n = 0; n &lt; columnCount; n++) &#123; try &#123; if (pDTScheme.Columns[n].DataType == typeof(System.Decimal) &amp;&amp; result[n] == &quot;&quot;) &#123; dr[n] = 0; &#125; else if (pDTScheme.Columns[n].DataType == typeof(System.Int32) &amp;&amp; result[n] == &quot;&quot;) &#123; dr[n] = 0; &#125; else if (pDTScheme.Columns[n].DataType != typeof(System.String) &amp;&amp; result[n] == &quot;&quot;) &#123; dr[n] = DBNull.Value; &#125; else if (pDTScheme.Columns[n].DataType != typeof(System.DateTime) &amp;&amp; result[n] == &quot;&quot;) &#123; dr[n] = DBNull.Value; &#125; else dr[n] = result[n]; &#125; catch &#123; dr[n] = DBNull.Value; &#125; &#125; Type t = null; DataColumn dc = null; object obj = null; for (int n = columnCount; n &lt; pDTScheme.Columns.Count; n++) &#123; dc = pDTScheme.Columns[n]; if (defaultValue != null) &#123; if (defaultValue.TryGetValue(dc.ColumnName, out obj)) &#123; dr[n] = obj; &#125; else &#123; if (dc.DefaultValue == DBNull.Value) &#123; t = pDTScheme.Columns[n].DataType; if (t == typeof(String)) dr[n] = &quot;&quot;; else if (t == typeof(Guid)) dr[n] = Guid.NewGuid(); else if (t == typeof(DateTime)) dr[n] = DateTime.Now; else if (t == typeof(int)) dr[n] = 0; else if (t == typeof(decimal)) dr[n] = 0.00; &#125; else &#123; dr[n] = pDTScheme.Columns[n].DefaultValue; &#125; &#125; &#125; else &#123; if (dc.DefaultValue == DBNull.Value) &#123; t = pDTScheme.Columns[n].DataType; if (t == typeof(String)) dr[n] = &quot;&quot;; else if (t == typeof(Guid)) dr[n] = Guid.NewGuid(); else if (t == typeof(DateTime)) dr[n] = DateTime.Now; else if (t == typeof(int)) dr[n] = 0; else if (t == typeof(decimal)) dr[n] = 0.00; &#125; else &#123; dr[n] = pDTScheme.Columns[n].DefaultValue; &#125; &#125; &#125; &#125; return dr; &#125; #region【封装的业务逻辑方法，配合InsertBossDetail进行使用】 public static DataTable XmlToDataTable(string dataName, out string tablename, out string exesql) &#123; tablename = string.Empty; exesql = string.Empty; string path = System.AppDomain.CurrentDomain.BaseDirectory + &quot;/Config/Imps.config&quot;; XmlDocument doc = new XmlDocument(); doc.Load(path); XmlNode tableRoot = doc.SelectSingleNode(&quot;/imps/imp[@name=&apos;&quot; + dataName + &quot;&apos;]&quot;); if (tableRoot != null) &#123; DataTable dt = new DataTable(); DataColumn dc = null; string defualtValue; tablename = tableRoot.SelectSingleNode(&quot;table&quot;).Attributes[&quot;name&quot;].Value; exesql = tableRoot.SelectSingleNode(&quot;sql&quot;).InnerText; foreach (XmlNode node in tableRoot.SelectSingleNode(&quot;table&quot;).ChildNodes) &#123; dc = new DataColumn(node.Attributes[&quot;name&quot;].Value.Trim(), Type.GetType(node.Attributes[&quot;type&quot;].Value.Trim())); if (!string.IsNullOrEmpty(defualtValue = node.Attributes[&quot;default&quot;] != null ? node.Attributes[&quot;default&quot;].Value.Trim() : null)) dc.DefaultValue = defualtValue; dt.Columns.Add(dc); &#125; return dt; &#125; return null; &#125; /// &lt;summary&gt; /// 用SBC方法插入数据库 /// &lt;/summary&gt; /// &lt;param name=&quot;ConnectionStringKey&quot;&gt;要插入的数据库&lt;/param&gt; /// &lt;param name=&quot;pDataTable&quot;&gt;要插入的DATATABLE&lt;/param&gt; /// &lt;param name=&quot;pTableName&quot;&gt;对应的数据库表名&lt;/param&gt; /// &lt;param name=&quot;pBulkCopyTimeout&quot;&gt;数据库连接过期时间,单位：秒&lt;/param&gt; public static void UseSBCInsertDB(string ConnectionStringKey, DataTable pDataTable, string pTableName, int pBulkCopyTimeout = -1, bool appingFlag = false) &#123; string connectionString = ConfigurationManager.ConnectionStrings[ConnectionStringKey].ConnectionString; using (SqlBulkCopy sqlBulkCopy = new SqlBulkCopy(connectionString)) &#123; sqlBulkCopy.DestinationTableName = pTableName; sqlBulkCopy.BatchSize = pDataTable.Rows.Count; if (pBulkCopyTimeout &gt; 0) sqlBulkCopy.BulkCopyTimeout = pBulkCopyTimeout; if (appingFlag) &#123; foreach (DataColumn dc in pDataTable.Columns) sqlBulkCopy.ColumnMappings.Add(dc.ColumnName, dc.ColumnName); &#125; using (SqlConnection sqlConnection = new SqlConnection(connectionString)) &#123; sqlConnection.Open(); if (pDataTable != null &amp;&amp; pDataTable.Rows.Count != 0) &#123; sqlBulkCopy.WriteToServer(pDataTable); &#125; &#125; &#125; &#125; #endregion #region【转换文件】 public static string TransferFile(string fileFullName, bool isDelOriFile = true) &#123; string path = Path.GetDirectoryName(fileFullName); //fileFullName.Substring(0, fileFullName.LastIndexOf(&apos;\\\\&apos;)); string newFileName = string.Format(&quot;&#123;0&#125;&#123;1&#125;.txt&quot;, path, DateTime.Now.ToString(&quot;yyyyMMddHHmmss&quot;)); Encoding en = GetEncoding(fileFullName, Encoding.Default); using (StreamReader sr = new StreamReader(fileFullName, en, true)) &#123; using (StreamWriter sw = new StreamWriter(newFileName, true, Encoding.UTF8)) &#123; string strTmp; while (!sr.EndOfStream) &#123; strTmp = sr.ReadLine(); if (!string.IsNullOrEmpty(strTmp)) &#123; sw.WriteLine(strTmp); &#125; &#125; sw.Flush(); sw.Close(); &#125; &#125; if (isDelOriFile &amp;&amp; File.Exists(fileFullName)) File.Delete(fileFullName); return newFileName; &#125; /// &lt;summary&gt; /// 取得一个文本文件的编码方式。 /// &lt;/summary&gt; /// &lt;param name=&quot;fileName&quot;&gt;文件名。&lt;/param&gt; /// &lt;param name=&quot;defaultEncoding&quot;&gt;默认编码方式。当该方法无法从文件的头部取得有效的前导符时，将返回该编码方式。&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Encoding GetEncoding(string fileName, Encoding defaultEncoding) &#123; using (FileStream fs = new FileStream(fileName, FileMode.Open)) &#123; Encoding targetEncoding = GetEncoding(fs, defaultEncoding); fs.Close(); return targetEncoding; &#125; &#125; /// &lt;summary&gt; /// 取得一个文本文件流的编码方式。 /// &lt;/summary&gt; /// &lt;param name=&quot;stream&quot;&gt;文本文件流。&lt;/param&gt; /// &lt;param name=&quot;defaultEncoding&quot;&gt;默认编码方式。当该方法无法从文件的头部取得有效的前导符时，将返回该编码方式。&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Encoding GetEncoding(FileStream stream, Encoding defaultEncoding) &#123; Encoding targetEncoding = defaultEncoding; if (stream != null &amp;&amp; stream.Length &gt;= 2) &#123; //保存文件流的前4个字节 byte byte1 = 0; byte byte2 = 0; byte byte3 = 0; byte byte4 = 0; //保存当前Seek位置 long origPos = stream.Seek(0, SeekOrigin.Begin); stream.Seek(0, SeekOrigin.Begin); int nByte = stream.ReadByte(); byte1 = Convert.ToByte(nByte); byte2 = Convert.ToByte(stream.ReadByte()); if (stream.Length &gt;= 3) &#123; byte3 = Convert.ToByte(stream.ReadByte()); &#125; if (stream.Length &gt;= 4) &#123; byte4 = Convert.ToByte(stream.ReadByte()); &#125; //根据文件流的前4个字节判断Encoding //Unicode &#123;0xFF, 0xFE&#125;; //BE-Unicode &#123;0xFE, 0xFF&#125;; //UTF8 = &#123;0xEF, 0xBB, 0xBF&#125;; if (byte1 == 0xFE &amp;&amp; byte2 == 0xFF)//UnicodeBe &#123; targetEncoding = Encoding.BigEndianUnicode; &#125; if (byte1 == 0xFF &amp;&amp; byte2 == 0xFE &amp;&amp; byte3 != 0xFF)//Unicode &#123; targetEncoding = Encoding.Unicode; &#125; if (byte1 == 0xEF &amp;&amp; byte2 == 0xBB &amp;&amp; byte3 == 0xBF)//UTF8 &#123; targetEncoding = Encoding.UTF8; &#125; //恢复Seek位置 stream.Seek(origPos, SeekOrigin.Begin); &#125; return targetEncoding; &#125; #endregion &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"csharp","slug":"csharp","permalink":"http://axss.gitee.io/tags/csharp/"}]},{"title":"C++引用的理解","slug":"技术/2018-03-09-C++引用的理解","date":"2013-07-13T12:46:25.000Z","updated":"2018-03-13T02:58:44.817Z","comments":true,"path":"2013/07/13/技术/2018-03-09-C++引用的理解/","link":"","permalink":"http://axss.gitee.io/2013/07/13/技术/2018-03-09-C++引用的理解/","excerpt":"","text":"定义引用引入了对象的一个同义词.定义引用的表示方法与定义指针相似,只是用&amp;代替了*.引用（reference）是c++对c语言的重要扩充.引用就是某一变量（目标）的一个别名,对引用的操作与对变量直接操作完全一样.其格式为:类型 &amp;引用变量名 = 已定义过的变量名. 特点一个变量可取多个别名. 引用必须初始化. 引用只能在初始化的时候引用一次 ,不能更改为转而引用其他变量. code基础引用12345678910111213void TestReference1 () &#123; int a = 1; int&amp; b = a; cout&lt;&lt;\"a:address-&gt;\" &lt;&lt;&amp;a&lt;&lt; endl; cout&lt;&lt;\"b:address-&gt;\" &lt;&lt;&amp;b&lt;&lt; endl; a = 2; b = 3; int&amp; c = b;// 引用一个引用变量,别名的别名 c = 4; &#125; const引用1234567891011121314151617void TestReference2 () &#123; int d1 = 4; const int &amp; d2 = d1; d1 = 5;//d1改变,d2的值也会改变. //d2 = 6;//不能给常量（不能被修改的量）赋值. const int d3 = 1; const int &amp; d4 = d3; //int&amp;d5 = d3; const int &amp; d6 = 5;//常量具有常性,只有常引用可以引用常量 double d7 = 1.1; //int&amp; d8 = d7;//d7是double类型,d8是int,d7赋值给 d8时要生成一个临时变量 //也就是说d8引用的是这个带有常性的临时变量,所以不能赋值. const int&amp; d9 = d7; &#125; 引用作参数123456789101112131415161718192021221.【值传递】如果形参为非引用的传值方式,则生成局部临时变量接收实参的值 void Swap (int left, int right) //值传递的方式无法实现交换,因为传参时对于参数left和right拷贝一临时副本,交换的是副本值,因为其是临时变量函数退出,变量销 &#123; //毁,并不会影响外部left和right的值. int temp = left; left = right ; right = temp ; &#125; 2.【引用传递】如果形参为引用类型,则形参是实参的别名. void Swap (int&amp; left, int&amp; right)//使用引用的话,不做临时拷贝,&amp;的使用说明此处只是原参数的另一个名字而已,所以修改时直接在原参数的基础上修改变量值. &#123; int temp = left; right = left ; left = temp ; &#125; 3.【指针传递】 void Swap (int* pLeft, int* pRight)//传入的是地址,因为地址是唯一的,所以指针通过地址的访问进而可修改其内容. &#123; int temp = *pLeft; *pLeft = *pRight; *pRight = temp; &#125; 注意不要返回一个临时变量的引用.如果返回对象出了当前函数的作用域依旧存在,则最好使用引用返回,因为这样更高效. 引用和指针的区别和联系（笔试热点）引用必须指向有效的变量,指针可以为空.sizeof指针对象和引用对象的意义不一样.sizeof引用得到的是所指向的变量的大小,而sizeof指针是对象地址的大小.指针和引用自增(++)自减(–)意义不一样.相对而言,引用比指针更安全. 引用和指针的区别和联系不同点指针是一个实体,而引用仅是个别名;引用使用时无需解引用(*),指针需要解引用;引用只能在定义时被初始化一次,之后不可变;指针可变;引用没有 const,指针有 const;const修饰的指针不可变;引用不能为空,指针可以为空;“sizeof 引用”得到的是所指向的变量(对象)的大小,而”sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小;指针和引用的自增(++)运算意义不一样;从内存分配上看:程序为指针变量分配内存区域,而引用不需要分配内存区域. 相同点两者都是地址的概念,指针指向一块儿内存,其内容为所指内存的地址;引用是某块儿内存的别名 const在C和C++中的含义(笔试热点)C中的const,功能比较单一,较容易理解作用:被修饰的内容不可更改.使用场合:修饰变量,函数参数,返回值等.（c++中应用场合要丰富的多）特点: 是运行时const,因此不能取代#define用于成为数组长度等需要编译时常量的情况.同时因为是运行时const,可以只定义而不初始化,而在运行时初始化.如 const int iConst;. 另外,在c中,const变量默认是外部链接,因此在不同的编译单元中如果有同名const变量,会引发命名冲突,编译时报错. c++中的const非类成员constconst变量默认是内部连接的,因此在不同的编译单元中可以有同名的const 变量定义.编译时常量,因此可以像#define一样使用,而且因为上面一点,可以在头文件中定义const变量,包含的不同的cpp文件（编译单元）中使用而不引起命名冲突.编译器默认不为const变量分配内存,除非:1. 使用 extern 申明, 2:程序中有引用const 变量的地址.c++中临时对象/内置变量默认具有const属性. 类中的const与c语言中的const一样,只是运行时常量,不能作为数组维数使用,即不能取代#define.在类中使用下面两种方式取代#define: 1:static const…enum{….}//enum 不占存储空间.类中的const 变量占用存储空间.类中的const成员变量需要在构造函数初始化列表中初始化.const 对象:在该对象生命周期内,必须保证没有任何成员变量被改变.const对象只能调用const成员函数.const成员函数: void fun() const … 不仅能被const对象调用,也能被非const对象调用,因此,如果确认一个任何成员函数不改变任何成员变量,应该习惯性将该函数定义成const类型.如果一个对象被定义成const,那么该const对象”可能”会被放入到ROM当中,这在嵌入式开发当中有时非常重要. 本文引用自：http://blog.csdn.net/Xiao__Tian__/article/details/51814617","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://axss.gitee.io/tags/c/"}]},{"title":"HEXO文档中带文件","slug":"技术/2018-03-08-HEXO文档中带文件","date":"2013-07-13T12:46:25.000Z","updated":"2018-03-13T02:58:44.816Z","comments":true,"path":"2013/07/13/技术/2018-03-08-HEXO文档中带文件/","link":"","permalink":"http://axss.gitee.io/2013/07/13/技术/2018-03-08-HEXO文档中带文件/","excerpt":"","text":"图片：","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"工具/插件","slug":"工具-插件","permalink":"http://axss.gitee.io/tags/工具-插件/"}]},{"title":"HUGO博客","slug":"技术/2015-04-07-HUGO博客","date":"2013-07-13T12:46:25.000Z","updated":"2018-03-13T02:58:44.810Z","comments":true,"path":"2013/07/13/技术/2015-04-07-HUGO博客/","link":"","permalink":"http://axss.gitee.io/2013/07/13/技术/2015-04-07-HUGO博客/","excerpt":"","text":"Step 1.配置Hugo：在github下载hugo release版本 (点击进入下载页)将hugo.exe路径配置到环境变量有想法的朋友也可以下载源码编译 Step 2.生成站点：使用Hugo快速生成站点，比如希望生成到 /path/to/site 路径： 1$ hugo new site /path/to/site $ cd /path/to/site站点目录结构： ▸ archetypes/ ▸ content/ ▸ layouts/ ▸ static/config.toml Step 3.创建文章：创建一个 about 页面,使用Hugo快速生成站点，比如希望生成到 /path/to/site 路径： 1$ hugo new about.md about.md 自动生成到了 content/about.md ，打开 about.md 看下： 12345+++date = &quot;2015-10-25T08:36:54-07:00&quot;draft = truetitle = &quot;about&quot;+++ 正文内容是 Markdown 格式的，+++ 之间的内容是 TOML 格式的，根据你的喜好，你可以换成 YAML 格式（使用 — 标记）或者 JSON 格式。 创建第一篇文章，放到 post 目录，方便之后生成聚合页面。 1$ hugo new post/first.md 打开编辑 post/first.md ： 1234---date: &quot;2015-10-25T08:36:54-07:00&quot;title: &quot;first&quot;--- Step 4.创建 themes 目录：12$ cd themes$ git clone https://github.com/aubm/hugo-code-editor-theme.git 运行Hugo在你的站点根目录执行 Hugo 命令进行调试： 1$ hugo server --theme=hugo-code-editor-theme --buildDrafts （注明：v0.15 版本之后，不再需要使用 –watchydeh 参数了） 浏览器里打开： http://localhost:1313 Step 5.部署：假设你需要部署在 GitHub Pages 上，首先在GitHub上创建一个Repository，命名为：GuoXingGitHub.github.io （GuoXingGitHub替换为你的github用户名）。 在站点根目录执行 Hugo 命令生成最终页面：1$ hugo --theme=hugo-code-editor-theme --baseUrl=&quot;https://GuoXingGitHub.github.io&quot; (注意，以上命令并不会生成草稿页面，如果未生成任何文章，请去掉文章头部的 draft=true 再重新生成) 如果一切顺利，所有静态页面都会生成到 public 目录，将pubilc目录里所有文件 push 到刚创建的Repository的 master 分支。 最后就能通过https://GuoXingGitHub.github.io/ 浏览了 Step 6.帮助： hugo中文文档: http://www.gohugo.org/ hugo官网: http://gohugo.io/","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"工具/插件","slug":"工具-插件","permalink":"http://axss.gitee.io/tags/工具-插件/"}]},{"title":"HEXO博客","slug":"技术/2015-04-07-HEXO博客","date":"2013-07-13T12:46:25.000Z","updated":"2018-03-13T02:58:44.809Z","comments":true,"path":"2013/07/13/技术/2015-04-07-HEXO博客/","link":"","permalink":"http://axss.gitee.io/2013/07/13/技术/2015-04-07-HEXO博客/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"工具/插件","slug":"工具-插件","permalink":"http://axss.gitee.io/tags/工具-插件/"}]},{"title":"Hexo-theme-pure主题books默认选择想读","slug":"技术/2018-03-09-Hexo-theme-pure主题books默认选择想读","date":"2013-07-13T12:46:25.000Z","updated":"2018-03-13T02:58:44.818Z","comments":true,"path":"2013/07/13/技术/2018-03-09-Hexo-theme-pure主题books默认选择想读/","link":"","permalink":"http://axss.gitee.io/2013/07/13/技术/2018-03-09-Hexo-theme-pure主题books默认选择想读/","excerpt":"","text":"Hexo-theme-pure主题books默认是选择在读的，现在我们需要将想读移动到前面 步骤Step 1.修改样式 在主题的layout-&gt;_partial的 archive-book.ejs调换想读和在读的顺序 Step 2.修改js 在主题的layout-&gt;_script的 douban.ejs 将show(reading)改成show(‘wish’)，然后刷新就有效果了","categories":[{"name":"技术","slug":"技术","permalink":"http://axss.gitee.io/categories/技术/"}],"tags":[{"name":"工具/插件","slug":"工具-插件","permalink":"http://axss.gitee.io/tags/工具-插件/"}]}]}